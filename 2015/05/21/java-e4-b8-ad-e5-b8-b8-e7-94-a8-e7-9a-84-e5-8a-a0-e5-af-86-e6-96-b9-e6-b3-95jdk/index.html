<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>Java中常用的加密方法(JDK) | 达合</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="加密，是以某种特殊的算法改变原有的信息数据，使得未授权的用户即使获得了已加密的信息，但因不知解密的方法，仍然无法了解信息的内容。大体上分为双向加密和单向加密，而双向加密又分为对称加密和非对称加密(有些资料将加密直接分为对称加密和非对称加密)。 双向加密大体意思就是明文加密后形成密文，可以通过算法还原成明文。而单向加密只是对信息进行了摘要计算，不能通过算法生成明文，单向加密从严格意思上说不能算是加密">
<meta name="keywords" content="达合">
<meta property="og:type" content="article">
<meta property="og:title" content="Java中常用的加密方法(JDK)">
<meta property="og:url" content="http://www.daahe.com/2015/05/21/java-e4-b8-ad-e5-b8-b8-e7-94-a8-e7-9a-84-e5-8a-a0-e5-af-86-e6-96-b9-e6-b3-95jdk/index.html">
<meta property="og:site_name" content="达合">
<meta property="og:description" content="加密，是以某种特殊的算法改变原有的信息数据，使得未授权的用户即使获得了已加密的信息，但因不知解密的方法，仍然无法了解信息的内容。大体上分为双向加密和单向加密，而双向加密又分为对称加密和非对称加密(有些资料将加密直接分为对称加密和非对称加密)。 双向加密大体意思就是明文加密后形成密文，可以通过算法还原成明文。而单向加密只是对信息进行了摘要计算，不能通过算法生成明文，单向加密从严格意思上说不能算是加密">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://blog.daahe.com/wp-content/uploads/2015/05/icon_star.png">
<meta property="og:image" content="http://blog.daahe.com/wp-content/uploads/2015/05/icon_star.png">
<meta property="og:image" content="http://blog.daahe.com/wp-content/uploads/2015/05/icon_star.png">
<meta property="og:image" content="http://blog.daahe.com/wp-content/uploads/2015/05/icon_star.png">
<meta property="og:image" content="http://blog.daahe.com/wp-content/uploads/2015/05/icon_star.png">
<meta property="og:image" content="http://blog.daahe.com/wp-content/uploads/2015/05/icon_star.png">
<meta property="og:image" content="http://blog.daahe.com/wp-content/uploads/2015/05/icon_star.png">
<meta property="og:image" content="http://blog.daahe.com/wp-content/uploads/2015/05/icon_star.png">
<meta property="og:image" content="http://blog.daahe.com/wp-content/uploads/2015/05/icon_star.png">
<meta property="og:image" content="http://blog.daahe.com/wp-content/uploads/2015/05/icon_star.png">
<meta property="og:image" content="http://blog.daahe.com/wp-content/uploads/2015/05/icon_star.png">
<meta property="og:image" content="http://blog.daahe.com/wp-content/uploads/2015/05/icon_star.png">
<meta property="og:image" content="http://blog.daahe.com/wp-content/uploads/2015/05/icon_star.png">
<meta property="og:image" content="http://blog.daahe.com/wp-content/uploads/2015/05/icon_star.png">
<meta property="og:updated_time" content="2018-10-21T02:31:58.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java中常用的加密方法(JDK)">
<meta name="twitter:description" content="加密，是以某种特殊的算法改变原有的信息数据，使得未授权的用户即使获得了已加密的信息，但因不知解密的方法，仍然无法了解信息的内容。大体上分为双向加密和单向加密，而双向加密又分为对称加密和非对称加密(有些资料将加密直接分为对称加密和非对称加密)。 双向加密大体意思就是明文加密后形成密文，可以通过算法还原成明文。而单向加密只是对信息进行了摘要计算，不能通过算法生成明文，单向加密从严格意思上说不能算是加密">
<meta name="twitter:image" content="http://blog.daahe.com/wp-content/uploads/2015/05/icon_star.png">
  
    <link rel="alternate" href="/atom.xml" title="达合" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <!-- link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css" -->
    <link href="https://fonts.googleapis.cnpmjs.org/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">

  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">达合</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">天地达 人自合</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://www.daahe.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-java-e4-b8-ad-e5-b8-b8-e7-94-a8-e7-9a-84-e5-8a-a0-e5-af-86-e6-96-b9-e6-b3-95jdk" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/05/21/java-e4-b8-ad-e5-b8-b8-e7-94-a8-e7-9a-84-e5-8a-a0-e5-af-86-e6-96-b9-e6-b3-95jdk/" class="article-date">
  <time datetime="2015-05-21T05:18:16.000Z" itemprop="datePublished">2015-05-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/未分类/">未分类</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Java中常用的加密方法(JDK)
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>加密，是以某种特殊的算法改变原有的信息数据，使得未授权的用户即使获得了已加密的信息，但因不知解密的方法，仍然无法了解信息的内容。大体上分为<strong>双向加密</strong>和<strong>单向加密</strong>，而双向加密又分为<strong>对称加密</strong>和<strong>非对称加密</strong>(有些资料将加密直接分为对称加密和非对称加密)。 双向加密大体意思就是明文加密后形成密文，可以通过算法还原成明文。而单向加密只是对信息进行了摘要计算，不能通过算法生成明文，单向加密从严格意思上说不能算是加密的一种，应该算是摘要算法吧。具体区分可以参考： (本人解释不清呢 …… ) <a href="http://security.group.iteye.com/group/wiki/1710-one-way-encryption-algorithm" target="_blank" rel="noopener">http://security.group.iteye.com/group/wiki/1710-one-way-encryption-algorithm</a> <strong>一、双向加密</strong> <strong>(一)、对称加密</strong> 采用单钥密码系统的加密方法，同一个密钥可以同时用作信息的加密和解密，这种加密方法称为对称加密，也称为单密钥加密。 需要对加密和解密使用相同密钥的加密算法。由于其速度，对称性加密通常在消息发送方需要加密大量数据时使用。对称性加密也称为密钥加密。 所谓对称，就是采用这种加密方法的双方使用方式用同样的密钥进行加密和解密。密钥是控制加密及解密过程的指令。 算法是一组规则，规定如何进行加密和解密。因此对称式加密本身不是安全的。 常用的对称加密有：DES、IDEA、RC2、RC4、SKIPJACK、RC5、AES算法等 对称加密一般java类中中定义成员</p>
<p>Java代码  <img src="http://blog.daahe.com/wp-content/uploads/2015/05/icon_star.png" alt="收藏代码"></p>
<ol>
<li>//KeyGenerator 提供对称密钥生成器的功能，支持各种算法</li>
<li>private KeyGenerator keygen;</li>
<li>//SecretKey 负责保存对称密钥</li>
<li>private SecretKey deskey;</li>
<li>//Cipher负责完成加密或解密工作</li>
<li>private Cipher c;</li>
<li>//该字节数组负责保存加密的结果</li>
<li>private byte[] cipherByte;</li>
</ol>
<p>在构造函数中初始化</p>
<p>Java代码  <img src="http://blog.daahe.com/wp-content/uploads/2015/05/icon_star.png" alt="收藏代码"></p>
<ol>
<li>Security.addProvider(new com.sun.crypto.provider.SunJCE());</li>
<li>//实例化支持DES算法的密钥生成器(算法名称命名需按规定，否则抛出异常)</li>
<li>keygen = KeyGenerator.getInstance(“DES”);//</li>
<li>//生成密钥</li>
<li>deskey = keygen.generateKey();</li>
<li>//生成Cipher对象,指定其支持的DES算法</li>
<li>c = Cipher.getInstance(“DES”);</li>
</ol>
<p><strong>1. DES</strong>算法为密码体制中的对称密码体制，又被成为美国数据加密标准，是1972年美国IBM公司研制的对称密码体制加密算法。 明文按64位进行分组, 密钥长64位，密钥事实上是56位参与DES运算（第8、16、24、32、40、48、56、64位是校验位， 使得每个密钥都有奇数个1）分组后的明文组和56位的密钥按位替代或交换的方法形成密文组的加密方法。</p>
<p>Java代码  <img src="http://blog.daahe.com/wp-content/uploads/2015/05/icon_star.png" alt="收藏代码"></p>
<ol>
<li>import java.security.InvalidKeyException;</li>
<li>import java.security.NoSuchAlgorithmException;</li>
<li><p>import java.security.Security;</p>
</li>
<li><p>import javax.crypto.BadPaddingException;</p>
</li>
<li>import javax.crypto.Cipher;</li>
<li>import javax.crypto.IllegalBlockSizeException;</li>
<li>import javax.crypto.KeyGenerator;</li>
<li>import javax.crypto.NoSuchPaddingException;</li>
<li><p>import javax.crypto.SecretKey;</p>
</li>
<li><p>public class EncrypDES {</p>
</li>
<li><p>//KeyGenerator 提供对称密钥生成器的功能，支持各种算法</p>
</li>
<li>private KeyGenerator keygen;</li>
<li>//SecretKey 负责保存对称密钥</li>
<li>private SecretKey deskey;</li>
<li>//Cipher负责完成加密或解密工作</li>
<li>private Cipher c;</li>
<li>//该字节数组负责保存加密的结果</li>
<li><p>private byte[] cipherByte;</p>
</li>
<li><p>public EncrypDES() throws NoSuchAlgorithmException, NoSuchPaddingException{</p>
</li>
<li>Security.addProvider(new com.sun.crypto.provider.SunJCE());</li>
<li>//实例化支持DES算法的密钥生成器(算法名称命名需按规定，否则抛出异常)</li>
<li>keygen = KeyGenerator.getInstance(“DES”);</li>
<li>//生成密钥</li>
<li>deskey = keygen.generateKey();</li>
<li>//生成Cipher对象,指定其支持的DES算法</li>
<li>c = Cipher.getInstance(“DES”);</li>
<li><p>}</p>
</li>
<li><p>/**</p>
</li>
<li><ul>
<li>对字符串加密</li>
</ul>
</li>
<li>* </li>
<li><ul>
<li>@param str</li>
</ul>
</li>
<li><ul>
<li>@return</li>
</ul>
</li>
<li><ul>
<li>@throws InvalidKeyException</li>
</ul>
</li>
<li><ul>
<li>@throws IllegalBlockSizeException</li>
</ul>
</li>
<li><ul>
<li>@throws BadPaddingException</li>
</ul>
</li>
<li>*/</li>
<li>public byte[] Encrytor(String str) throws InvalidKeyException,</li>
<li>IllegalBlockSizeException, BadPaddingException {</li>
<li>// 根据密钥，对Cipher对象进行初始化，ENCRYPT_MODE表示加密模式</li>
<li>c.init(Cipher.ENCRYPT_MODE, deskey);</li>
<li>byte[] src = str.getBytes();</li>
<li>// 加密，结果保存进cipherByte</li>
<li>cipherByte = c.doFinal(src);</li>
<li>return cipherByte;</li>
<li><p>}</p>
</li>
<li><p>/**</p>
</li>
<li><ul>
<li>对字符串解密</li>
</ul>
</li>
<li>* </li>
<li><ul>
<li>@param buff</li>
</ul>
</li>
<li><ul>
<li>@return</li>
</ul>
</li>
<li><ul>
<li>@throws InvalidKeyException</li>
</ul>
</li>
<li><ul>
<li>@throws IllegalBlockSizeException</li>
</ul>
</li>
<li><ul>
<li>@throws BadPaddingException</li>
</ul>
</li>
<li>*/</li>
<li>public byte[] Decryptor(byte[] buff) throws InvalidKeyException,</li>
<li>IllegalBlockSizeException, BadPaddingException {</li>
<li>// 根据密钥，对Cipher对象进行初始化，DECRYPT_MODE表示加密模式</li>
<li>c.init(Cipher.DECRYPT_MODE, deskey);</li>
<li>cipherByte = c.doFinal(buff);</li>
<li>return cipherByte;</li>
<li><p>}</p>
</li>
<li><p>/**</p>
</li>
<li><ul>
<li>@param args</li>
</ul>
</li>
<li><ul>
<li>@throws NoSuchPaddingException </li>
</ul>
</li>
<li><ul>
<li>@throws NoSuchAlgorithmException </li>
</ul>
</li>
<li><ul>
<li>@throws BadPaddingException </li>
</ul>
</li>
<li><ul>
<li>@throws IllegalBlockSizeException </li>
</ul>
</li>
<li><ul>
<li>@throws InvalidKeyException </li>
</ul>
</li>
<li>*/</li>
<li>public static void main(String[] args) throws Exception {</li>
<li>EncrypDES de1 = new EncrypDES();</li>
<li>String msg =”郭XX-搞笑相声全集”;</li>
<li>byte[] encontent = de1.Encrytor(msg);</li>
<li>byte[] decontent = de1.Decryptor(encontent);</li>
<li>System.out.println(“明文是:” + msg);</li>
<li>System.out.println(“加密后:” + new String(encontent));</li>
<li>System.out.println(“解密后:” + new String(decontent));</li>
<li><p>}</p>
</li>
<li><p>}</p>
</li>
</ol>
<p><strong>2. 3DES</strong>又称Triple DES，是DES加密算法的一种模式，它使用3条56位的密钥对3DES 数据进行三次加密。数据加密标准（DES）是美国的一种由来已久的加密标准，它使用对称密钥加密法，并于1981年被ANSI组织规范为ANSI X.3.92。DES使用56位密钥和密码块的方法，而在密码块的方法中，文本被分成64位大小的文本块然后再进行加密。比起最初的DES，3DES更为安全。 3DES（即Triple DES）是DES向AES过渡的加密算法（1999年，NIST将3-DES指定为过渡的加密标准），是DES的一个更安全的变形。它以DES为基本模块，通过组合分组方法设计出分组加密算法，其具体实现如下： 设Ek()和Dk()代表DES算法的加密和解密过程，K代表DES算法使用的密钥，P代表明文，C代表密文， 这样， 3DES加密过程为：C=Ek3(Dk2(Ek1(P))) 3DES解密过程为：P=Dk1((EK2(Dk3(C)))</p>
<p>Java代码  <img src="http://blog.daahe.com/wp-content/uploads/2015/05/icon_star.png" alt="收藏代码"></p>
<ol>
<li>import java.security.InvalidKeyException;</li>
<li>import java.security.NoSuchAlgorithmException;</li>
<li><p>import java.security.Security;</p>
</li>
<li><p>import javax.crypto.BadPaddingException;</p>
</li>
<li>import javax.crypto.Cipher;</li>
<li>import javax.crypto.IllegalBlockSizeException;</li>
<li>import javax.crypto.KeyGenerator;</li>
<li>import javax.crypto.NoSuchPaddingException;</li>
<li><p>import javax.crypto.SecretKey;</p>
</li>
<li><p>public class EncrypDES3 {</p>
</li>
<li><p>// KeyGenerator 提供对称密钥生成器的功能，支持各种算法</p>
</li>
<li>private KeyGenerator keygen;</li>
<li>// SecretKey 负责保存对称密钥</li>
<li>private SecretKey deskey;</li>
<li>// Cipher负责完成加密或解密工作</li>
<li>private Cipher c;</li>
<li>// 该字节数组负责保存加密的结果</li>
<li><p>private byte[] cipherByte;</p>
</li>
<li><p>public EncrypDES3() throws NoSuchAlgorithmException, NoSuchPaddingException {</p>
</li>
<li>Security.addProvider(new com.sun.crypto.provider.SunJCE());</li>
<li>// 实例化支持DES算法的密钥生成器(算法名称命名需按规定，否则抛出异常)</li>
<li>keygen = KeyGenerator.getInstance(“DESede”);</li>
<li>// 生成密钥</li>
<li>deskey = keygen.generateKey();</li>
<li>// 生成Cipher对象,指定其支持的DES算法</li>
<li>c = Cipher.getInstance(“DESede”);</li>
<li><p>}</p>
</li>
<li><p>/**</p>
</li>
<li><ul>
<li>对字符串加密</li>
</ul>
</li>
<li>* </li>
<li><ul>
<li>@param str</li>
</ul>
</li>
<li><ul>
<li>@return</li>
</ul>
</li>
<li><ul>
<li>@throws InvalidKeyException</li>
</ul>
</li>
<li><ul>
<li>@throws IllegalBlockSizeException</li>
</ul>
</li>
<li><ul>
<li>@throws BadPaddingException</li>
</ul>
</li>
<li>*/</li>
<li>public byte[] Encrytor(String str) throws InvalidKeyException,</li>
<li>IllegalBlockSizeException, BadPaddingException {</li>
<li>// 根据密钥，对Cipher对象进行初始化，ENCRYPT_MODE表示加密模式</li>
<li>c.init(Cipher.ENCRYPT_MODE, deskey);</li>
<li>byte[] src = str.getBytes();</li>
<li>// 加密，结果保存进cipherByte</li>
<li>cipherByte = c.doFinal(src);</li>
<li>return cipherByte;</li>
<li><p>}</p>
</li>
<li><p>/**</p>
</li>
<li><ul>
<li>对字符串解密</li>
</ul>
</li>
<li>* </li>
<li><ul>
<li>@param buff</li>
</ul>
</li>
<li><ul>
<li>@return</li>
</ul>
</li>
<li><ul>
<li>@throws InvalidKeyException</li>
</ul>
</li>
<li><ul>
<li>@throws IllegalBlockSizeException</li>
</ul>
</li>
<li><ul>
<li>@throws BadPaddingException</li>
</ul>
</li>
<li>*/</li>
<li>public byte[] Decryptor(byte[] buff) throws InvalidKeyException,</li>
<li>IllegalBlockSizeException, BadPaddingException {</li>
<li>// 根据密钥，对Cipher对象进行初始化，DECRYPT_MODE表示加密模式</li>
<li>c.init(Cipher.DECRYPT_MODE, deskey);</li>
<li>cipherByte = c.doFinal(buff);</li>
<li>return cipherByte;</li>
<li><p>}</p>
</li>
<li><p>/**</p>
</li>
<li><ul>
<li>@param args</li>
</ul>
</li>
<li><ul>
<li>@throws NoSuchPaddingException </li>
</ul>
</li>
<li><ul>
<li>@throws NoSuchAlgorithmException </li>
</ul>
</li>
<li><ul>
<li>@throws BadPaddingException </li>
</ul>
</li>
<li><ul>
<li>@throws IllegalBlockSizeException </li>
</ul>
</li>
<li><ul>
<li>@throws InvalidKeyException </li>
</ul>
</li>
<li>*/</li>
<li>public static void main(String[] args) throws Exception {</li>
<li>EncrypDES3 des = new EncrypDES3();</li>
<li>String msg =”郭XX-搞笑相声全集”;</li>
<li>byte[] encontent = des.Encrytor(msg);</li>
<li>byte[] decontent = des.Decryptor(encontent);</li>
<li>System.out.println(“明文是:” + msg);</li>
<li>System.out.println(“加密后:” + new String(encontent));</li>
<li><p>System.out.println(“解密后:” + new String(decontent));</p>
</li>
<li><p>}</p>
</li>
<li><p>}</p>
</li>
</ol>
<p><strong>3. AES</strong>密码学中的高级加密标准（Advanced Encryption Standard，AES），又称  高级加密标准 Rijndael加密法，是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的DES，已经被多方分析且广为全世界所使用。经过五年的甄选流程，高级加密标准由美国国家标准与技术研究院（NIST）于2001年11月26日发布于FIPS PUB 197，并在2002年5月26日成为有效的标准。2006年，高级加密标准已然成为对称密钥加密中最流行的算法之一。 　　该算法为比利时密码学家Joan Daemen和Vincent Rijmen所设计，结合两位作者的名字，以Rijndael之命名之，投稿高级加密标准的甄选流程。（Rijdael的发音近于 “Rhinedoll”。）</p>
<p>Java代码  <img src="http://blog.daahe.com/wp-content/uploads/2015/05/icon_star.png" alt="收藏代码"></p>
<ol>
<li>import java.security.InvalidKeyException;</li>
<li>import java.security.NoSuchAlgorithmException;</li>
<li><p>import java.security.Security;</p>
</li>
<li><p>import javax.crypto.BadPaddingException;</p>
</li>
<li>import javax.crypto.Cipher;</li>
<li>import javax.crypto.IllegalBlockSizeException;</li>
<li>import javax.crypto.KeyGenerator;</li>
<li>import javax.crypto.NoSuchPaddingException;</li>
<li><p>import javax.crypto.SecretKey;</p>
</li>
<li><p>public class EncrypAES {</p>
</li>
<li><p>//KeyGenerator 提供对称密钥生成器的功能，支持各种算法</p>
</li>
<li>private KeyGenerator keygen;</li>
<li>//SecretKey 负责保存对称密钥</li>
<li>private SecretKey deskey;</li>
<li>//Cipher负责完成加密或解密工作</li>
<li>private Cipher c;</li>
<li>//该字节数组负责保存加密的结果</li>
<li><p>private byte[] cipherByte;</p>
</li>
<li><p>public EncrypAES() throws NoSuchAlgorithmException, NoSuchPaddingException{</p>
</li>
<li>Security.addProvider(new com.sun.crypto.provider.SunJCE());</li>
<li>//实例化支持DES算法的密钥生成器(算法名称命名需按规定，否则抛出异常)</li>
<li>keygen = KeyGenerator.getInstance(“AES”);</li>
<li>//生成密钥</li>
<li>deskey = keygen.generateKey();</li>
<li>//生成Cipher对象,指定其支持的DES算法</li>
<li>c = Cipher.getInstance(“AES”);</li>
<li><p>}</p>
</li>
<li><p>/**</p>
</li>
<li><ul>
<li>对字符串加密</li>
</ul>
</li>
<li>* </li>
<li><ul>
<li>@param str</li>
</ul>
</li>
<li><ul>
<li>@return</li>
</ul>
</li>
<li><ul>
<li>@throws InvalidKeyException</li>
</ul>
</li>
<li><ul>
<li>@throws IllegalBlockSizeException</li>
</ul>
</li>
<li><ul>
<li>@throws BadPaddingException</li>
</ul>
</li>
<li>*/</li>
<li>public byte[] Encrytor(String str) throws InvalidKeyException,</li>
<li>IllegalBlockSizeException, BadPaddingException {</li>
<li>// 根据密钥，对Cipher对象进行初始化，ENCRYPT_MODE表示加密模式</li>
<li>c.init(Cipher.ENCRYPT_MODE, deskey);</li>
<li>byte[] src = str.getBytes();</li>
<li>// 加密，结果保存进cipherByte</li>
<li>cipherByte = c.doFinal(src);</li>
<li>return cipherByte;</li>
<li><p>}</p>
</li>
<li><p>/**</p>
</li>
<li><ul>
<li>对字符串解密</li>
</ul>
</li>
<li>* </li>
<li><ul>
<li>@param buff</li>
</ul>
</li>
<li><ul>
<li>@return</li>
</ul>
</li>
<li><ul>
<li>@throws InvalidKeyException</li>
</ul>
</li>
<li><ul>
<li>@throws IllegalBlockSizeException</li>
</ul>
</li>
<li><ul>
<li>@throws BadPaddingException</li>
</ul>
</li>
<li>*/</li>
<li>public byte[] Decryptor(byte[] buff) throws InvalidKeyException,</li>
<li>IllegalBlockSizeException, BadPaddingException {</li>
<li>// 根据密钥，对Cipher对象进行初始化，DECRYPT_MODE表示加密模式</li>
<li>c.init(Cipher.DECRYPT_MODE, deskey);</li>
<li>cipherByte = c.doFinal(buff);</li>
<li>return cipherByte;</li>
<li><p>}</p>
</li>
<li><p>/**</p>
</li>
<li><ul>
<li>@param args</li>
</ul>
</li>
<li><ul>
<li>@throws NoSuchPaddingException </li>
</ul>
</li>
<li><ul>
<li>@throws NoSuchAlgorithmException </li>
</ul>
</li>
<li><ul>
<li>@throws BadPaddingException </li>
</ul>
</li>
<li><ul>
<li>@throws IllegalBlockSizeException </li>
</ul>
</li>
<li><ul>
<li>@throws InvalidKeyException </li>
</ul>
</li>
<li>*/</li>
<li>public static void main(String[] args) throws Exception {</li>
<li>EncrypAES de1 = new EncrypAES();</li>
<li>String msg =”郭XX-搞笑相声全集”;</li>
<li>byte[] encontent = de1.Encrytor(msg);</li>
<li>byte[] decontent = de1.Decryptor(encontent);</li>
<li>System.out.println(“明文是:” + msg);</li>
<li>System.out.println(“加密后:” + new String(encontent));</li>
<li>System.out.println(“解密后:” + new String(decontent));</li>
<li><p>}</p>
</li>
<li><p>}</p>
</li>
</ol>
<p><strong>(二)、非对称加密</strong> 1976年，美国学者Dime和Henman为解决信息公开传送和密钥管理问题，提出一种新的密钥交换协议，允许在不安全的媒体上的通讯双方交换信息，安全地达成一致的密钥，这就是“公开密钥系统”。相对于“对称加密算法”这种方法也叫做“非对称加密算法”。 与对称加密算法不同，非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥 （privatekey）。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。 <strong>1. RSA</strong> 公钥加密算法是1977年由Ron Rivest、Adi Shamirh和LenAdleman在（美国麻省理工学院）开发的。RSA取名来自开发他们三者的名字。RSA是目前最有影响力的公钥加密算法，它能够抵抗到目前为止已知的所有密码攻击，已被ISO推荐为公钥数据加密标准。RSA算法基于一个十分简单的数论事实：将两个大素数相乘十分容易，但那时想要对其乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥。</p>
<p>Java代码  <img src="http://blog.daahe.com/wp-content/uploads/2015/05/icon_star.png" alt="收藏代码"></p>
<ol>
<li>import java.security.InvalidKeyException;</li>
<li>import java.security.KeyPair;</li>
<li>import java.security.KeyPairGenerator;</li>
<li>import java.security.NoSuchAlgorithmException;</li>
<li>import java.security.interfaces.RSAPrivateKey;</li>
<li><p>import java.security.interfaces.RSAPublicKey;</p>
</li>
<li><p>import javax.crypto.BadPaddingException;</p>
</li>
<li>import javax.crypto.Cipher;</li>
<li>import javax.crypto.IllegalBlockSizeException;</li>
<li><p>import javax.crypto.NoSuchPaddingException;</p>
</li>
<li><p>public class EncrypRSA {</p>
</li>
<li><p>/**</p>
</li>
<li><ul>
<li>加密</li>
</ul>
</li>
<li><ul>
<li>@param publicKey</li>
</ul>
</li>
<li><ul>
<li>@param srcBytes</li>
</ul>
</li>
<li><ul>
<li>@return</li>
</ul>
</li>
<li><ul>
<li>@throws NoSuchAlgorithmException</li>
</ul>
</li>
<li><ul>
<li>@throws NoSuchPaddingException</li>
</ul>
</li>
<li><ul>
<li>@throws InvalidKeyException</li>
</ul>
</li>
<li><ul>
<li>@throws IllegalBlockSizeException</li>
</ul>
</li>
<li><ul>
<li>@throws BadPaddingException</li>
</ul>
</li>
<li>*/</li>
<li>protected byte[] encrypt(RSAPublicKey publicKey,byte[] srcBytes) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException{</li>
<li>if(publicKey!=null){</li>
<li>//Cipher负责完成加密或解密工作，基于RSA</li>
<li>Cipher cipher = Cipher.getInstance(“RSA”);</li>
<li>//根据公钥，对Cipher对象进行初始化</li>
<li>cipher.init(Cipher.ENCRYPT_MODE, publicKey);</li>
<li>byte[] resultBytes = cipher.doFinal(srcBytes);</li>
<li>return resultBytes;</li>
<li>}</li>
<li>return null;</li>
<li><p>}</p>
</li>
<li><p>/**</p>
</li>
<li><ul>
<li>解密 </li>
</ul>
</li>
<li><ul>
<li>@param privateKey</li>
</ul>
</li>
<li><ul>
<li>@param srcBytes</li>
</ul>
</li>
<li><ul>
<li>@return</li>
</ul>
</li>
<li><ul>
<li>@throws NoSuchAlgorithmException</li>
</ul>
</li>
<li><ul>
<li>@throws NoSuchPaddingException</li>
</ul>
</li>
<li><ul>
<li>@throws InvalidKeyException</li>
</ul>
</li>
<li><ul>
<li>@throws IllegalBlockSizeException</li>
</ul>
</li>
<li><ul>
<li>@throws BadPaddingException</li>
</ul>
</li>
<li>*/</li>
<li>protected byte[] decrypt(RSAPrivateKey privateKey,byte[] srcBytes) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException{</li>
<li>if(privateKey!=null){</li>
<li>//Cipher负责完成加密或解密工作，基于RSA</li>
<li>Cipher cipher = Cipher.getInstance(“RSA”);</li>
<li>//根据公钥，对Cipher对象进行初始化</li>
<li>cipher.init(Cipher.DECRYPT_MODE, privateKey);</li>
<li>byte[] resultBytes = cipher.doFinal(srcBytes);</li>
<li>return resultBytes;</li>
<li>}</li>
<li>return null;</li>
<li><p>}</p>
</li>
<li><p>/**</p>
</li>
<li><ul>
<li>@param args</li>
</ul>
</li>
<li><ul>
<li>@throws NoSuchAlgorithmException </li>
</ul>
</li>
<li><ul>
<li>@throws BadPaddingException </li>
</ul>
</li>
<li><ul>
<li>@throws IllegalBlockSizeException </li>
</ul>
</li>
<li><ul>
<li>@throws NoSuchPaddingException </li>
</ul>
</li>
<li><ul>
<li>@throws InvalidKeyException </li>
</ul>
</li>
<li>*/</li>
<li>public static void main(String[] args) throws NoSuchAlgorithmException, InvalidKeyException, NoSuchPaddingException, IllegalBlockSizeException, BadPaddingException {</li>
<li>EncrypRSA rsa = new EncrypRSA();</li>
<li>String msg = “郭XX-精品相声”;</li>
<li>//KeyPairGenerator类用于生成公钥和私钥对，基于RSA算法生成对象</li>
<li>KeyPairGenerator keyPairGen = KeyPairGenerator.getInstance(“RSA”);</li>
<li>//初始化密钥对生成器，密钥大小为1024位</li>
<li>keyPairGen.initialize(1024);</li>
<li>//生成一个密钥对，保存在keyPair中</li>
<li>KeyPair keyPair = keyPairGen.generateKeyPair();</li>
<li>//得到私钥</li>
<li>RSAPrivateKey privateKey = (RSAPrivateKey)keyPair.getPrivate();</li>
<li>//得到公钥</li>
<li><p>RSAPublicKey publicKey = (RSAPublicKey)keyPair.getPublic();</p>
</li>
<li><p>//用公钥加密</p>
</li>
<li>byte[] srcBytes = msg.getBytes();</li>
<li><p>byte[] resultBytes = rsa.encrypt(publicKey, srcBytes);</p>
</li>
<li><p>//用私钥解密</p>
</li>
<li><p>byte[] decBytes = rsa.decrypt(privateKey, resultBytes);</p>
</li>
<li><p>System.out.println(“明文是:” + msg);</p>
</li>
<li>System.out.println(“加密后是:” + new String(resultBytes));</li>
<li>System.out.println(“解密后是:” + new String(decBytes));</li>
<li><p>}</p>
</li>
<li><p>}</p>
</li>
</ol>
<p><strong>2. DSA</strong> Digital Signature Algorithm (DSA)是Schnorr和ElGamal签名算法的变种，被美国NIST作为DSS(DigitalSignature Standard)。(感觉有点复杂，没有附代码) 详见<a href="http://63938525.iteye.com/blog/1051565" target="_blank" rel="noopener">http://63938525.iteye.com/blog/1051565</a> <strong>(三)、题外话 MySQL加密解密函数</strong> MySQL有两个函数来支持这种类型的加密，分别叫做ENCODE()和DECODE()。 下面是一个简单的实例：</p>
<p>Mysql代码  <img src="http://blog.daahe.com/wp-content/uploads/2015/05/icon_star.png" alt="收藏代码"></p>
<ol>
<li><p>mysql&gt; INSERT INTO users (username,password) VALUES (‘joe’,ENCODE(‘guessme’,’abr’));</p>
</li>
<li><p>Query OK， 1 row affected （0.14 sec）</p>
</li>
</ol>
<p>其中，Joe的密码是guessme，它通过密钥abracadabra被加密。要注意的是，加密完的结果是一个二进制字符串，如下所示： 提示：虽然ENCODE()和DECODE()这两个函数能够满足大多数的要求，但是有的时候您希望使用强度更高的加密手段。在这种情况下，您可以使用AES_ENCRYPT()和AES_DECRYPT()函数，它们的工作方式是相同的，但是加密强度更高。 单向加密与双向加密不同，一旦数据被加密就没有办法颠倒这一过程。因此密码的验证包括对用户输入内容的重新加密，并将它与保存的密文进行比对，看是否匹配。一种简单的单向加密方式是MD5校验码。MySQL的MD5（）函数会为您的数据创建一个“指纹”并将它保存起来，供验证测试使用。下面就是如何使用它的一个简单例子：</p>
<p>Mysql代码  <img src="http://blog.daahe.com/wp-content/uploads/2015/05/icon_star.png" alt="收藏代码"></p>
<ol>
<li><p>mysql&gt; INSERT INTO users (username,password) VALUES (‘joe’,MD5(‘guessme’));</p>
</li>
<li><p>Query OK， 1 row affected （0.00 sec）</p>
</li>
</ol>
<p>或者，您考虑一下使用ENCRYPT（）函数，它使用系统底层的crypt（）系统调用来完成加密。这个函数有两个参数：一个是要被加密的字符串，另一个是双（或者多）字符的“salt”。它然后会用salt加密字符串；这个salt然后可以被用来再次加密用户输入的内容，并将它与先前加密的字符串进行比对。下面一个例子说明了如何使用它：</p>
<p>Mysql代码  <img src="http://blog.daahe.com/wp-content/uploads/2015/05/icon_star.png" alt="收藏代码"></p>
<ol>
<li><p>mysql&gt; INSERT INTO users (username,password) VALUES(‘joe’， ENCRYPT(‘guessme’,’ab’));</p>
</li>
<li><p>Query OK， 1 row affected （0.00 sec）</p>
</li>
</ol>
<p>提示：ENCRYPT()只能用在UNIX、LINIX系统上，因为它需要用到底层的crypt()库。 <strong>二、单向加密(信息摘要)</strong> Java一般需要获取对象MessageDigest来实现单项加密(信息摘要)。 <strong>1. MD5</strong> 即Message-Digest Algorithm 5（信息-摘要算法 5），用于确保信息传输完整一致。是计算机广泛使用的杂凑算法之一（又译摘要算法、哈希算法），主流编程语言普遍已有MD5实现。将数据（如汉字）运算为另一固定长度值，是杂凑算法的基础原理，MD5的前身有MD2、MD3和MD4。MD5的作用是让大容量信息在用数字签名软件签署私人密钥前被”压缩”成一种保密的格式（就是把一个任意长度的字节串变换成一定长的十六进制数字串）。 除了MD5以外，其中比较有名的还有sha-1、RIPEMD以及Haval等</p>
<p>Java代码  <img src="http://blog.daahe.com/wp-content/uploads/2015/05/icon_star.png" alt="收藏代码"></p>
<ol>
<li>import java.security.MessageDigest;</li>
<li><p>import java.security.NoSuchAlgorithmException;</p>
</li>
<li><p>public class EncrypMD5 {</p>
</li>
<li><p>public byte[] eccrypt(String info) throws NoSuchAlgorithmException{</p>
</li>
<li>//根据MD5算法生成MessageDigest对象</li>
<li>MessageDigest md5 = MessageDigest.getInstance(“MD5”);</li>
<li>byte[] srcBytes = info.getBytes();</li>
<li>//使用srcBytes更新摘要</li>
<li>md5.update(srcBytes);</li>
<li>//完成哈希计算，得到result</li>
<li>byte[] resultBytes = md5.digest();</li>
<li>return resultBytes;</li>
<li><p>}</p>
</li>
<li><p>public static void main(String args[]) throws NoSuchAlgorithmException{</p>
</li>
<li>String msg = “郭XX-精品相声技术”;</li>
<li>EncrypMD5 md5 = new EncrypMD5();</li>
<li><p>byte[] resultBytes = md5.eccrypt(msg);</p>
</li>
<li><p>System.out.println(“密文是：” + new String(resultBytes));</p>
</li>
<li>System.out.println(“明文是：” + msg);</li>
<li><p>}</p>
</li>
<li><p>}</p>
</li>
</ol>
<p><strong>2. SHA</strong> 是一种数据加密算法，该算法经过加密专家多年来的发展和改进已日益完善，现在已成为公认的最安全的散列算法之一，并被广泛使用。该算法的思想是接收一段明文，然后以一种不可逆的方式将它转换成一段（通常更小）密文，也可以简单的理解为取一串输入码（称为预映射或信息），并把它们转化为长度较短、位数固定的输出序列即散列值（也称为信息摘要或信息认证代码）的过程。散列函数值可以说时对明文的一种“指纹”或是“摘要”所以对散列值的数字签名就可以视为对此明文的数字签名。</p>
<p>Java代码  <img src="http://blog.daahe.com/wp-content/uploads/2015/05/icon_star.png" alt="收藏代码"></p>
<ol>
<li>import java.security.MessageDigest;</li>
<li><p>import java.security.NoSuchAlgorithmException;</p>
</li>
<li><p>public class EncrypSHA {</p>
</li>
<li><p>public byte[] eccrypt(String info) throws NoSuchAlgorithmException{</p>
</li>
<li>MessageDigest md5 = MessageDigest.getInstance(“SHA”);</li>
<li>byte[] srcBytes = info.getBytes();</li>
<li>//使用srcBytes更新摘要</li>
<li>md5.update(srcBytes);</li>
<li>//完成哈希计算，得到result</li>
<li>byte[] resultBytes = md5.digest();</li>
<li>return resultBytes;</li>
<li><p>}</p>
</li>
<li><p>/**</p>
</li>
<li><ul>
<li>@param args</li>
</ul>
</li>
<li><ul>
<li>@throws NoSuchAlgorithmException </li>
</ul>
</li>
<li>*/</li>
<li>public static void main(String[] args) throws NoSuchAlgorithmException {</li>
<li>String msg = “郭XX-精品相声技术”;</li>
<li>EncrypSHA sha = new EncrypSHA();</li>
<li>byte[] resultBytes = sha.eccrypt(msg);</li>
<li>System.out.println(“明文是：” + msg);</li>
<li><p>System.out.println(“密文是：” + new String(resultBytes));</p>
</li>
<li><p>}</p>
</li>
<li><p>}</p>
</li>
</ol>
<p>附件中是以上几种的源代码，附带额外的两种使用方式。 增加一种关于文件的哈希算法源代码：</p>
<p>Java代码  <img src="http://blog.daahe.com/wp-content/uploads/2015/05/icon_star.png" alt="收藏代码"></p>
<ol>
<li>import java.io.FileInputStream;</li>
<li>import java.io.InputStream;</li>
<li><p>import java.security.MessageDigest;</p>
</li>
<li><p>public class FileHashUtil {</p>
</li>
<li><p>public static final char[] hexChar = {</p>
</li>
<li>‘0’, ‘1’, ‘2’, ‘3’, ‘4’, ‘5’, ‘6’, ‘7’, ‘8’, ‘9’, ‘a’, ‘b’, ‘c’, ‘d’, ‘e’, ‘f’ };</li>
<li><p>public static final String[] hashTypes = new String[] { “MD2”, “MD5”, “SHA1”, “SHA-256”, “SHA-384”, “SHA-512” };</p>
</li>
<li><p>public void MD5File(String fileName) throws Exception{</p>
</li>
<li>//String fileName = args[0];</li>
<li>System.out.println(“需要获取hash的文件为：　“ + fileName);</li>
<li>java.util.List<messagedigest> mds = new java.util.ArrayList<messagedigest>();</messagedigest></messagedigest></li>
<li>for (String hashType : hashTypes) {</li>
<li>MessageDigest md = MessageDigest.getInstance(hashType);</li>
<li>mds.add(md);</li>
<li>}</li>
<li>InputStream fis = null;</li>
<li>try {</li>
<li>fis = new FileInputStream(fileName);</li>
<li>byte[] buffer = new byte[1024];</li>
<li>int numRead = 0;</li>
<li>while ((numRead = fis.read(buffer)) &gt; 0) {</li>
<li>for (MessageDigest md : mds) {</li>
<li>md.update(buffer, 0, numRead);</li>
<li>}</li>
<li>}</li>
<li>} catch (Exception ex) {</li>
<li>ex.printStackTrace();</li>
<li>} finally {</li>
<li>if (fis != null) {</li>
<li>fis.close();</li>
<li>}</li>
<li>}</li>
<li>for (MessageDigest md : mds) {</li>
<li>System.out.println(md.getAlgorithm() + “ == “ + toHexString(md.digest()));</li>
<li>}</li>
<li><p>}</p>
</li>
<li><p>public static void main(String[] args) throws Exception {</p>
</li>
<li>String[] fileName = new String[] {“D:/hapfish/ShellFolder.java”,”D:/hapfish/ShellFolder - 副本.java”,</li>
<li>“E:/ShellFolder - 副本.java”,”E:/ShellFolder.txt”,”D:/hapfish/ShellFolder.jpg”,</li>
<li>“E:/ShellFolder增加字符.txt”,”D:/hapfish/birosoft.jar”};</li>
<li>FileHashUtil files  = new FileHashUtil();</li>
<li>for(int i=0;i&lt;fileName.length;i++){</li>
<li>files.MD5File(fileName[i]);</li>
<li><p>}</p>
</li>
<li><p>}</p>
</li>
<li><p>public static String toHexString(byte[] b) {</p>
</li>
<li>StringBuilder sb = new StringBuilder(b.length * 2);</li>
<li>for (int i = 0; i &lt; b.length; i++) {</li>
<li>sb.append(hexChar[(b[i] &amp; 0xf0) &gt;&gt;&gt; 4]);</li>
<li>sb.append(hexChar[b[i] &amp; 0x0f]);</li>
<li>}</li>
<li>return sb.toString();</li>
<li><p>}</p>
</li>
<li><p>}</p>
</li>
</ol>
<p>运行说明</p>
<p>说明代码  <img src="http://blog.daahe.com/wp-content/uploads/2015/05/icon_star.png" alt="收藏代码"></p>
<ol>
<li>“D:/hapfish/ShellFolder.java”,</li>
<li>“D:/hapfish/ShellFolder - 副本.java”,</li>
<li>“E:/ShellFolder - 副本.java”,</li>
<li>“E:/ShellFolder.txt”,</li>
<li>“D:/hapfish/ShellFolder.jpg”,</li>
<li><p>以上五个文件是同一文件经过复制、改扩展名的，最后计算哈希结果是一致的。</p>
</li>
<li><p>“E:/ShellFolder增加字符.txt” 增加了几个字符串，就不一样了</p>
</li>
<li><p>“D:/hapfish/birosoft.jar” 完全不相关的另外一个文件</p>
</li>
</ol>
<p>运行结果：</p>
<p>Java代码  <img src="http://blog.daahe.com/wp-content/uploads/2015/05/icon_star.png" alt="收藏代码"></p>
<ol>
<li>需要获取hash的文件为：　D:/hapfish/ShellFolder.java</li>
<li>MD2 == 3a755a99c5e407005cd45ebd856b4649</li>
<li>MD5 == 5d08d440fa911d1e418c69a90b83cd86</li>
<li>SHA1 == 522c8c4f4ff1dd669e251c2ab854c3033a51ca63</li>
<li>SHA-256 == d1feb0c73c10a759e88bd240cb9d56d0598b4ff83a0704c6679f7ba12f6c4d99</li>
<li>SHA-384 == 8f8c9da4cd7241c58af3c52b49199033f2dcf3d67f421753999f87511618d9ea2d738e8c16b9b68a7572d06108ff10f6</li>
<li>SHA-512 == 4711579daee3ddacbaea189310348956cb43bcaaf0099f3be047b06f16c1a20a6b71ee3a4ee018128d647e9f2ef0d644747672238e49a8da3d0cd26dfe597458</li>
<li>需要获取hash的文件为：　D:/hapfish/ShellFolder - 副本.java</li>
<li>MD2 == 3a755a99c5e407005cd45ebd856b4649</li>
<li>MD5 == 5d08d440fa911d1e418c69a90b83cd86</li>
<li>SHA1 == 522c8c4f4ff1dd669e251c2ab854c3033a51ca63</li>
<li>SHA-256 == d1feb0c73c10a759e88bd240cb9d56d0598b4ff83a0704c6679f7ba12f6c4d99</li>
<li>SHA-384 == 8f8c9da4cd7241c58af3c52b49199033f2dcf3d67f421753999f87511618d9ea2d738e8c16b9b68a7572d06108ff10f6</li>
<li>SHA-512 == 4711579daee3ddacbaea189310348956cb43bcaaf0099f3be047b06f16c1a20a6b71ee3a4ee018128d647e9f2ef0d644747672238e49a8da3d0cd26dfe597458</li>
<li>需要获取hash的文件为：　E:/ShellFolder - 副本.java</li>
<li>MD2 == 3a755a99c5e407005cd45ebd856b4649</li>
<li>MD5 == 5d08d440fa911d1e418c69a90b83cd86</li>
<li>SHA1 == 522c8c4f4ff1dd669e251c2ab854c3033a51ca63</li>
<li>SHA-256 == d1feb0c73c10a759e88bd240cb9d56d0598b4ff83a0704c6679f7ba12f6c4d99</li>
<li>SHA-384 == 8f8c9da4cd7241c58af3c52b49199033f2dcf3d67f421753999f87511618d9ea2d738e8c16b9b68a7572d06108ff10f6</li>
<li>SHA-512 == 4711579daee3ddacbaea189310348956cb43bcaaf0099f3be047b06f16c1a20a6b71ee3a4ee018128d647e9f2ef0d644747672238e49a8da3d0cd26dfe597458</li>
<li>需要获取hash的文件为：　E:/ShellFolder.txt</li>
<li>MD2 == 3a755a99c5e407005cd45ebd856b4649</li>
<li>MD5 == 5d08d440fa911d1e418c69a90b83cd86</li>
<li>SHA1 == 522c8c4f4ff1dd669e251c2ab854c3033a51ca63</li>
<li>SHA-256 == d1feb0c73c10a759e88bd240cb9d56d0598b4ff83a0704c6679f7ba12f6c4d99</li>
<li>SHA-384 == 8f8c9da4cd7241c58af3c52b49199033f2dcf3d67f421753999f87511618d9ea2d738e8c16b9b68a7572d06108ff10f6</li>
<li>SHA-512 == 4711579daee3ddacbaea189310348956cb43bcaaf0099f3be047b06f16c1a20a6b71ee3a4ee018128d647e9f2ef0d644747672238e49a8da3d0cd26dfe597458</li>
<li>需要获取hash的文件为：　D:/hapfish/ShellFolder.jpg</li>
<li>MD2 == 3a755a99c5e407005cd45ebd856b4649</li>
<li>MD5 == 5d08d440fa911d1e418c69a90b83cd86</li>
<li>SHA1 == 522c8c4f4ff1dd669e251c2ab854c3033a51ca63</li>
<li>SHA-256 == d1feb0c73c10a759e88bd240cb9d56d0598b4ff83a0704c6679f7ba12f6c4d99</li>
<li>SHA-384 == 8f8c9da4cd7241c58af3c52b49199033f2dcf3d67f421753999f87511618d9ea2d738e8c16b9b68a7572d06108ff10f6</li>
<li>SHA-512 == 4711579daee3ddacbaea189310348956cb43bcaaf0099f3be047b06f16c1a20a6b71ee3a4ee018128d647e9f2ef0d644747672238e49a8da3d0cd26dfe597458</li>
<li>需要获取hash的文件为：　E:/ShellFolder增加字符.txt</li>
<li>MD2 == f2717c24c6c0e110457bd17221c9ca6c</li>
<li>MD5 == c49e353a7c4c26bd7ccb5e90917c230f</li>
<li>SHA1 == 477c8a9e465bfaa4be42d35c032a17f7e6b42b97</li>
<li>SHA-256 == 9fa18adaf242ebcdc6563922d84c2a163c82e1a24db2eb2b73978ed1f354a8a3</li>
<li>SHA-384 == 4eee8f8e6d64d21c15dc01fa049f4d12a3b8e1d94d87763fe0bea75ab5ea8432fa8251289ece45ee39fe3d36b3c3020c</li>
<li>SHA-512 == e852ec0ff77250be497389d2f5a1818c18bb66106b9905c4ee26fe0d256eb3b77e0ce9a28a84e4b67e4332ba37ec3aa7518148e3a682318c0fc34c391f45c201</li>
<li>需要获取hash的文件为：　D:/hapfish/birosoft.jar</li>
<li>MD2 == 38c5e1404718916dec59c33cafc909b3</li>
<li>MD5 == dc3e2cc4fb3949cf3660e0f5f8c3fba3</li>
<li>SHA1 == cde3dc25498afc5a563af0bb0eb54dc45f71bb28</li>
<li>SHA-256 == adf6a961c70c6ea677dff066fc5d896fb0beb4dd442ca0eb619ae1d1b04291e5</li>
<li>SHA-384 == fe7c6b754893c53ebd82bb53703fb5cc32115c9a38f98072f73def90729b271ee3c5c78e258bd9ff5ee5476193c2178b</li>
<li>SHA-512 == a15376f327256a6e049dfbdc5c2ad3a98bffccc6fa92ee01ff53db6b04471ca0f45ca28f76ff4a6911b57825afa046671299141f2499d71f1dac618c92385491</li>
</ol>
<p>最后，把运行结果贴出来有点占空间，主要为了说明表述自己的猜想。一般来说同一哈希算法对同一文件(镜像、扩展名被修改)所产生的结果应该是一致的。 因此有个猜想，在baidu文库、腾讯的群共享上传时，先会判断是否有相同文件，从某种可能上来说也采用了对文件的哈希算法，毕竟从本地运算一个哈希算法后获得的数值要比把整个文件传过去比较实惠得多。而且字符串的比较也是很方便的。 对于某一种哈希算法，存在一种可能：就是两个不同的文件，计算出来的哈希值可能是一样的。当然为了保险，可以用两种甚至更多的哈希算法，只有在每种算法获得的哈希值都相同时，才能判断是同一个文件。 如果我们也对用户上传的文件进行哈希计算的话，就可以节省资源，同样的文件按理说可以减少上传次数……</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.daahe.com/2015/05/21/java-e4-b8-ad-e5-b8-b8-e7-94-a8-e7-9a-84-e5-8a-a0-e5-af-86-e6-96-b9-e6-b3-95jdk/" data-id="cjo7ddqr3007rof0f8v6dkv3n" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2015/07/22/e6-96-b0-e4-bc-81-e4-b8-9a-e5-88-9d-e5-a7-8b-e5-8c-96/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          新企业初始化
        
      </div>
    </a>
  
  
    <a href="/2015/05/08/quartz-e4-bb-bb-e5-8a-a1-e8-b0-83-e5-ba-a6-e5-bf-ab-e9-80-9f-e5-85-a5-e9-97-a8/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Quartz任务调度快速入门</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/j2ee/">j2ee</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/j2ee/Linux/">Linux</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android/道听途说/">道听途说</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/DataCross/">DataCross</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flex/">Flex</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hibernate/">Hibernate</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/j2ee/">j2ee</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/jvm/">jvm</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/redis/">redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/未分类/">未分类</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/生活/">生活</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/生活/道听途说/">道听途说</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/私人日志/">私人日志</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/道听途说/">道听途说</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Google-Map/">Google Map</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MapView/">MapView</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/UI设计/">UI设计</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/datacross/">datacross</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ui/">ui</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/xp-启动不输入密码/">xp 启动不输入密码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/切换/">切换</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/原则/">原则</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/开发/">开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据转换/">数据转换</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/格式转换/">格式转换</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/横屏/">横屏</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/注销/">注销</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/监听/">监听</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/竖屏/">竖屏</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/返回/">返回</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android/" style="font-size: 20px;">Android</a> <a href="/tags/Google-Map/" style="font-size: 10px;">Google Map</a> <a href="/tags/MapView/" style="font-size: 10px;">MapView</a> <a href="/tags/UI设计/" style="font-size: 10px;">UI设计</a> <a href="/tags/datacross/" style="font-size: 10px;">datacross</a> <a href="/tags/ui/" style="font-size: 10px;">ui</a> <a href="/tags/xp-启动不输入密码/" style="font-size: 10px;">xp 启动不输入密码</a> <a href="/tags/切换/" style="font-size: 10px;">切换</a> <a href="/tags/原则/" style="font-size: 10px;">原则</a> <a href="/tags/开发/" style="font-size: 15px;">开发</a> <a href="/tags/数据转换/" style="font-size: 10px;">数据转换</a> <a href="/tags/格式转换/" style="font-size: 10px;">格式转换</a> <a href="/tags/横屏/" style="font-size: 10px;">横屏</a> <a href="/tags/注销/" style="font-size: 10px;">注销</a> <a href="/tags/监听/" style="font-size: 10px;">监听</a> <a href="/tags/竖屏/" style="font-size: 10px;">竖屏</a> <a href="/tags/返回/" style="font-size: 10px;">返回</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">October 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">August 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/07/">July 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/">May 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04/">April 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/03/">March 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/05/">May 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/02/">February 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/12/">December 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/11/">November 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/10/">October 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/05/">May 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/04/">April 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/03/">March 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/01/">January 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/12/">December 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/11/">November 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/09/">September 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/02/">February 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/01/">January 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/12/">December 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/11/">November 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/10/">October 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/09/">September 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/08/">August 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/07/">July 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/06/">June 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/05/">May 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/04/">April 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/03/">March 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/02/">February 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/01/">January 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2010/12/">December 2010</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2010/11/">November 2010</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2010/09/">September 2010</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2010/08/">August 2010</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2007/12/">December 2007</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2007/10/">October 2007</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2007/09/">September 2007</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/11/07/java-multi-thread/">java-multi-thread</a>
          </li>
        
          <li>
            <a href="/2018/11/07/java-io/">java-io</a>
          </li>
        
          <li>
            <a href="/2018/11/07/message-queue2/">消息队列</a>
          </li>
        
          <li>
            <a href="/2018/11/07/cache/">缓存技术</a>
          </li>
        
          <li>
            <a href="/2018/11/07/j2ee-container2/">J2EE 容器</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 daahe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    
<script src="https://code.jquery.com/jquery-3.3.1.min.js"></script>
<!-- script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script -->


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>