<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>达合</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="达合">
<meta name="keywords" content="达合">
<meta property="og:type" content="website">
<meta property="og:title" content="达合">
<meta property="og:url" content="http://www.daahe.com/page/2/index.html">
<meta property="og:site_name" content="达合">
<meta property="og:description" content="达合">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="达合">
<meta name="twitter:description" content="达合">
  
    <link rel="alternate" href="/atom.xml" title="达合" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <!-- link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css" -->
    <link href="https://fonts.googleapis.cnpmjs.org/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">

  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">达合</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">天地达 人自合</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://www.daahe.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-feature" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/21/feature/" class="article-date">
  <time datetime="2018-10-21T03:44:26.000Z" itemprop="datePublished">2018-10-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/未分类/">未分类</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/21/feature/">我们的未来</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1、脑电波带来的第n次信息技术革命，彻底改变了人类传统的沟通方式。无言的交流。<br>2、重新定义人类。人类的进化，会从基因层面上，吸收其他物种的优秀基因，可以有选择地长出其他物种的器官。人类也不再千篇一律的相似，一个牛头马面的人不再罕见。满世界形形色色的人类，人类不再局限于两只手脚，一个脑袋，直立行走。也不再局限于陆地生活。那时人类将重新定义自己。那时人与人的区别，就像现在不同服装的区别。 人类可以通过基因制造出和目前各类电子设备功能相同的器官，如无线电收发器、显示器。 人类可以适应更高的温度，更低的寒冷。 数字化的人类，人类的生死，把一个人的思维意识记忆等数字化，人类的死亡也仅仅只是身体的报废。通过把数字化的意识记忆复制到新的躯体大脑中，满血复活。 一个人的消亡，是意识记忆的消亡。保存意识记忆的U盘丢失或损坏。把一个人的意识记忆的数字带到世界的另一端 起死回生。 人类指导下的有目的的进化，代替自然选择。人类设计师，生物在自然界缓慢进化。人类设计师可以快速设计出更优秀的自己。<br>3、交通<br>4、能源<br>5、政治<br>6、思想<br>7、外星生物<br>8、人类能否完全认知整个世界，把整个宇宙搞明白。 大道至简，我们的认知过程，总是从一个大的特定到一个小的特定。就如果洋葱，我们被包裹在最里层，想知道外面的宇宙。我们只有一层一层的向外认知。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.daahe.com/2018/10/21/feature/" data-id="cjo7e3rr0006zbh0fi7na56l2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-react" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/21/react/" class="article-date">
  <time datetime="2018-10-20T17:33:53.000Z" itemprop="datePublished">2018-10-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/21/react/">react</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>react</p>
<p><a href="https://www.cnblogs.com/elvirangel/p/6879799.html" target="_blank" rel="noopener">https://www.cnblogs.com/elvirangel/p/6879799.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.daahe.com/2018/10/21/react/" data-id="cjo7e3rrz0097bh0fghjzcl7y" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/21/hello-world/" class="article-date">
  <time datetime="2018-10-20T16:37:57.000Z" itemprop="datePublished">2018-10-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/21/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.daahe.com/2018/10/21/hello-world/" data-id="cjo7e3rr30076bh0fq4hzhty9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-jvm" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/09/23/jvm/" class="article-date">
  <time datetime="2017-09-22T18:21:55.000Z" itemprop="datePublished">2017-09-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/jvm/">jvm</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/23/jvm/">jvm</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="http://www.jianshu.com/p/c9ac99b87d56" target="_blank" rel="noopener">JVM内存模型你只要看这一篇就够了</a> <a href="http://www.cnblogs.com/dingyingsi/p/3760447.html" target="_blank" rel="noopener">深入理解JVM—JVM内存模型</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.daahe.com/2017/09/23/jvm/" data-id="cjo7e3rrj0089bh0fjfjtdc6i" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-redis-e4-b8-ba-e4-bb-80-e4-b9-88-e4-bd-bf-e7-94-a8-e5-8d-95-e8-bf-9b-e7-a8-8b-e5-8d-95-e7-ba-bf-e7-a8-8b-e6-96-b9-e5-bc-8f-e4-b9-9f-e8-bf-99-e4-b9-88-e5-bf-ab" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/09/22/redis-e4-b8-ba-e4-bb-80-e4-b9-88-e4-bd-bf-e7-94-a8-e5-8d-95-e8-bf-9b-e7-a8-8b-e5-8d-95-e7-ba-bf-e7-a8-8b-e6-96-b9-e5-bc-8f-e4-b9-9f-e8-bf-99-e4-b9-88-e5-bf-ab/" class="article-date">
  <time datetime="2017-09-22T03:27:07.000Z" itemprop="datePublished">2017-09-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/redis/">redis</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/22/redis-e4-b8-ba-e4-bb-80-e4-b9-88-e4-bd-bf-e7-94-a8-e5-8d-95-e8-bf-9b-e7-a8-8b-e5-8d-95-e7-ba-bf-e7-a8-8b-e6-96-b9-e5-bc-8f-e4-b9-9f-e8-bf-99-e4-b9-88-e5-bf-ab/">Redis 为什么使用单进程单线程方式也这么快</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Redis 采用的是基于内存的采用的是单进程单线程模型的 KV 数据库，由 C 语言编写。官方提供的数据是可以达到100000+的 qps。这个数据不比采用单进程多线程的同样基于内存的 KV 数据库 Memcached 差。 Redis 快的主要原因有： 完全基于内存； 数据结构简单，对数据操作也简单； 使用多路 I/O 复用模型； 第一、二点不细讲，主要围绕第三点采用多路 I/O 复用技术来展开。 多路 I/O 复用模型是利用 select、poll、epoll 可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有 I/O 事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll 是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络 IO 的时间消耗），且 Redis 在内存中操作数据的速度非常快（内存内的操作不会成为这里的性能瓶颈），主要以上两点造就了 Redis 具有很高的吞吐量。 <a href="http://blog.daahe.com/wp-content/uploads/2017/09/3587411016.png" target="_blank" rel="noopener"><img src="http://blog.daahe.com/wp-content/uploads/2017/09/3587411016.png" alt=""></a> 多路 I/O 复用模型 和 Memcached 不同，Redis 并没有直接使用 Libevent，而是自己完成了一个非常轻量级的对 select、epoll、evport、kqueue 这些通用的接口的实现。在不同的系统调用选用适合的接口，linux 下默认是 epoll。因为 Libevent 比较重，更通用，代码量也就很庞大，拥有很多 Redis 用不上的功能，Redis 为了追求“轻巧”并且去除依赖，就选择自己去封装了一套。 单进程单线程好处 代码更清晰，处理逻辑更简单 不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗 不存在多进程或者多线程导致的切换而消耗 CPU 单进程单线程弊端 无法发挥多核 CPU 性能，不过可以通过在单机开多个 Redis 实例来完善； 其他一些优秀的开源软件采用的模型 多进程单线程模型：Nginx 单进程多线程模型：Memcached</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.daahe.com/2017/09/22/redis-e4-b8-ba-e4-bb-80-e4-b9-88-e4-bd-bf-e7-94-a8-e5-8d-95-e8-bf-9b-e7-a8-8b-e5-8d-95-e7-ba-bf-e7-a8-8b-e6-96-b9-e5-bc-8f-e4-b9-9f-e8-bf-99-e4-b9-88-e5-bf-ab/" data-id="cjo7e3rs2009dbh0fvf8s2u2u" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-sql-server-e4-b8-adwith-nolock-e6-b5-85-e6-9e-90" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/10/14/sql-server-e4-b8-adwith-nolock-e6-b5-85-e6-9e-90/" class="article-date">
  <time datetime="2015-10-13T23:06:00.000Z" itemprop="datePublished">2015-10-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/数据库/">数据库</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/14/sql-server-e4-b8-adwith-nolock-e6-b5-85-e6-9e-90/">SQL Server 中WITH (NOLOCK)浅析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>概念介绍</strong>  开发人员喜欢在SQL脚本中使用WITH(NOLOCK), WITH(NOLOCK)其实是表提示（table_hint）中的一种。它等同于 READUNCOMMITTED 。 具体的功能作用如下所示（摘自MSDN）：    1： 指定允许脏读。不发布共享锁来阻止其他事务修改当前事务读取的数据，其他事务设置的排他锁不会阻碍当前事务读取锁定数据。允许脏读可能产生较多的并发操作，但其代价是读取以后会被其他事务回滚的数据修改。这可能会使您的事务出错，向用户显示从未提交过的数据，或者导致用户两次看到记录（或根本看不到记录）。有关脏读、不可重复读和幻读的详细信息，请参阅<a href="http://msdn.microsoft.com/zh-cn/library/ms190805(v=sql.105" target="_blank" rel="noopener">并发影响</a>.aspx)。    2： READUNCOMMITTED 和 NOLOCK 提示仅适用于数据锁。所有查询（包括那些带有 READUNCOMMITTED 和 NOLOCK 提示的查询）都会在编译和执行过程中获取 Sch-S（架构稳定性）锁。因此，当并发事务持有表的 Sch-M（架构修改）锁时，将阻塞查询。例如，数据定义语言 (DDL) 操作在修改表的架构信息之前获取 Sch-M 锁。所有并发查询（包括那些使用 READUNCOMMITTED 或 NOLOCK 提示运行的查询）都会在尝试获取 Sch-S 锁时被阻塞。相反，持有 Sch-S 锁的查询将阻塞尝试获取 Sch-M 锁的并发事务。有关锁行为的详细信息，请参阅<a href="http://msdn.microsoft.com/zh-cn/library/ms186396(v=sql.105" target="_blank" rel="noopener">锁兼容性（数据库引擎）</a>.aspx)。    3:  不能为通过插入、更新或删除操作修改过的表指定 READUNCOMMITTED 和 NOLOCK。SQL Server 查询优化器忽略 FROM 子句中应用于 UPDATE 或 DELETE 语句的目标表的 READUNCOMMITTED 和 NOLOCK 提示。   <strong>功能与缺陷</strong>       使用WIHT(NOLOCK)有利也有弊，所以在决定使用之前，你一定需要了解清楚WITH(NOLOCK)的功能和缺陷，看其是否适合你的业务需求,不要觉得它能提升性能，稀里糊涂的就使用它。       1：使用WITH(NOLOCK)时查询不受其它排他锁阻塞     打开会话窗口1，执行下面脚本，不提交也不回滚事务，模拟事务真在执行过程当中</p>
<p>BEGIN TRAN</p>
<pre><code>   UPDATE TEST SET NAME=&apos;Timmy&apos; WHERE OBJECT_ID =1;

   --ROLLBACK



打开会话窗口2，执行下面脚本，你会发现执行结果一直查询不出来（其实才两条记录）。当前会话被阻塞了
</code></pre><p>SELECT * FROM TEST;</p>
<pre><code>打开会话窗口3，执行下面脚本，查看阻塞情况，你会发现在会话2被会话1给阻塞了，会话2的等待类型为LCK\_M\_S：“当某任务正在等待获取共享锁时出现”
</code></pre><p>  SELECT wt.blocking_session_id                    AS BlockingSessesionId</p>
<pre><code>,sp.program_name                           AS ProgramName

,COALESCE(sp.LOGINAME, sp.nt_username)     AS HostName

,ec1.client\_net\_address                    AS ClientIpAddress

,db.name                                   AS DatabaseName

,wt.wait_type                              AS WaitType

,ec1.connect_time                          AS BlockingStartTime

,wt.WAIT\_DURATION\_MS/1000                  AS WaitDuration

,ec1.session_id                            AS BlockedSessionId

,h1.TEXT                                   AS BlockedSQLText

,h2.TEXT                                   AS BlockingSQLText
</code></pre><p>  FROM sys.dm_tran_locks AS tl</p>
<p>  INNER JOIN sys.databases db</p>
<pre><code>ON db.database\_id = tl.resource\_database_id
</code></pre><p>  INNER JOIN sys.dm_os_waiting_tasks AS wt</p>
<pre><code>ON tl.lock\_owner\_address = wt.resource_address
</code></pre><p>  INNER JOIN sys.dm_exec_connections ec1</p>
<pre><code>ON ec1.session\_id = tl.request\_session_id
</code></pre><p>  INNER JOIN sys.dm_exec_connections ec2</p>
<pre><code>ON ec2.session\_id = wt.blocking\_session_id
</code></pre><p>  LEFT OUTER JOIN master.dbo.sysprocesses sp</p>
<pre><code>ON SP.spid = wt.blocking\_session\_id
</code></pre><p>  CROSS APPLY sys.dm_exec_sql_text(ec1.most_recent_sql_handle) AS h1</p>
<p>  CROSS APPLY sys.dm_exec_sql_text(ec2.most_recent_sql_handle) AS h2</p>
<pre><code>[![clipboard](http://images.cnitblog.com/blog/73542/201408/301157577044817.png &quot;clipboard&quot;)](http://images.cnitblog.com/blog/73542/201408/301204003457660.png)   此时查看会话1（会话1的会话ID为53，执行脚本1前，可以用SELECT  @@spid查看会话ID）的锁信息情况，你会发现表TEST(ObjId=1893581784)持有的锁信息如下所示   [![clipboard[1]](http://images.cnitblog.com/blog/73542/201408/301157597984445.png &quot;clipboard[1]&quot;)](http://images.cnitblog.com/blog/73542/201408/301204032351645.png)  打开会话窗口4，执行下面脚本.你会发现查询结果很快就出来，会话4并不会被会话1阻塞。     SELECT * FROM TEST WITH(NOLOCK) 从上面模拟的这个小例子可以看出，正是由于加上WITH(NOLOCK)提示后，会话1中事务设置的排他锁不会阻碍当前事务读取锁定数据，所以会话4不会被阻塞，从而提升并发时查询性能。   2：WITH(NOLOCK) 不发布共享锁来阻止其他事务修改当前事务读取的数据，这个就不举例子了。 本质上WITH(NOLOCK)是通过减少锁和不受排它锁影响来减少阻塞，从而提高并发时的性能。所谓凡事有利也有弊，WITH(NOLOCK)在提升性能的同时，也会产生脏读现象。 如下所示，表TEST有两条记录，我准备更新OBJECT_ID=1的记录，此时事务既没有提交也没有回滚 [![clipboard[2]](http://images.cnitblog.com/blog/73542/201408/301158015956927.png &quot;clipboard[2]&quot;)](http://images.cnitblog.com/blog/73542/201408/301204049076101.png)
</code></pre><p>BEGIN TRAN</p>
<p>UPDATE TEST SET NAME=’Timmy’ WHERE OBJECT_ID =1;</p>
<p>–ROLLBACK</p>
<p>此时另外一个会话使用WITH(NOLOCK)查到的记录为未提交的记录值 [<img src="http://images.cnitblog.com/blog/73542/201408/301158030165927.png" alt="clipboard[3]" title="clipboard[3]">](<a href="http://images.cnitblog.com/blog/73542/201408/301204060011901.png" target="_blank" rel="noopener">http://images.cnitblog.com/blog/73542/201408/301204060011901.png</a>) 假如由于某种原因，该事务回滚了，那么我们读取到的OBJECT_ID=1的记录就是一条脏数据。 脏读又称无效数据的读出，是指在数据库访问中，<a href="http://baike.baidu.com/view/121511.htm" target="_blank" rel="noopener">事务</a>T1将某一值修改，然后事务T2读取该值，此后T1因为某种原因撤销对该值的修改，这就导致了T2所读取到的数据是无效的。   <strong>WITH(NOLOCK)使用场景</strong>   什么时候可以使用WITH(NOLOCK)? 什么时候不能使用WITH(NOLOCK),这个要视你系统业务情况，综合考虑性能情况与业务要求来决定是否使用WITH(NOLOCK), 例如涉及到金融或会计成本之类的系统，出现脏读那是要产生严重问题的。关键业务系统也要慎重考虑。大体来说一般有下面一些场景可以使用WITH(NOLOCK)    1: 基础数据表，这些表的数据很少变更。    2：历史数据表，这些表的数据很少变更。    3：业务允许脏读情况出现涉及的表。    4：数据量超大的表，出于性能考虑，而允许脏读。 另外一点就是不要滥用WITH(NOLOCK),我发现有个奇怪现象，很多开发知道WITH(NOLOCK),但是有不了解脏读，习惯性的使用WITH(NOLOCK)。   <strong>WITH(NOLOCK)与 NOLOCK区别</strong>   为了搞清楚WITH(NOLOCK)与NOLOCK的区别，我查了大量的资料，我们先看看下面三个SQL语句有啥区别     SELECT <em> FROM TEST NOLOCK     SELECT </em> FROM TEST (NOLOCK);     SELECT * FROM TEST WITH(NOLOCK); 上面的问题概括起来也就是说NOLOCK、(NOLOCK)、 WITH(NOLOCK)的区别： 1： NOLOCK这样的写法，其实NOLOCK其实只是别名的作用，而没有任何实质作用。所以不要粗心将(NOLOCK)写成NOLOCK 2：（NOLOCK）与WITH(NOLOCK)其实功能上是一样的。(NOLOCK)只是WITH(NOLOCK)的别名,但是在SQL Server 2008及以后版本中，(NOLOCK)不推荐使用了，”不借助 WITH 关键字指定表提示”的写法已经过时了。 具体参见MSDN <a href="http://msdn.microsoft.com/zh-cn/library/ms143729" target="_blank" rel="noopener">http://msdn.microsoft.com/zh-cn/library/ms143729</a>%28SQL.100%29.aspx     2.1  至于网上说WITH(NOLOCK)在SQL SERVER 2000不生效，我验证后发现完全是个谬论。     2.2  在使用链接服务器的SQL当中，(NOLOCK)不会生效，WITH(NOLOCK)才会生效。如下所示 [<img src="http://images.cnitblog.com/blog/73542/201408/301158046103640.png" alt="clipboard[4]" title="clipboard[4]">](<a href="http://images.cnitblog.com/blog/73542/201408/301204068133785.png" target="_blank" rel="noopener">http://images.cnitblog.com/blog/73542/201408/301204068133785.png</a>)     消息 4122，级别 16，状态 1，第 1 行     Remote table-valued function calls are not allowed.   <strong>WITH(NOLOCK)会不会产生锁</strong>     很多人误以为使用了WITH(NOLOCK)后，数据库库不会产生任何锁。实质上，使用了WITH(NOLOCK)后，数据库依然对该表对象生成Sch-S（架构稳定性）锁以及DB类型的共享锁， 如下所示，可以在一个会话中查询一个大表，然后在另外一个会话中查看锁信息(也可以使用SQL Profile查看会话锁信息)     不使用WTIH(NOLOCK) [<img src="http://images.cnitblog.com/blog/73542/201408/301158061412139.png" alt="clipboard[5]" title="clipboard[5]">](<a href="http://images.cnitblog.com/blog/73542/201408/301204078603599.png" target="_blank" rel="noopener">http://images.cnitblog.com/blog/73542/201408/301204078603599.png</a>)   使用WITH(NOLOCK) [<img src="http://images.cnitblog.com/blog/73542/201408/301158077047095.png" alt="clipboard[6]" title="clipboard[6]">](<a href="http://images.cnitblog.com/blog/73542/201408/301204088769183.png" target="_blank" rel="noopener">http://images.cnitblog.com/blog/73542/201408/301204088769183.png</a>)   从上可以看出使用WITH(NOLOCK)后，数据库并不是不生成相关锁。  对比可以发现使用WITH(NOLOCK)后，数据库只会生成DB类型的共享锁、以及TAB类型的架构稳定性锁. 另外，使用WITH(NOLOCK)并不是说就不会被其它会话阻塞，依然可能会产生Schema Change Blocking 会话1：执行下面SQL语句，暂时不提交，模拟事务正在执行</p>
<p>BEGIN TRAN</p>
<p>  ALTER TABLE TEST ADD Grade VARCHAR(10) ;</p>
<p>会话2：执行下面语句，你会发现会话被阻塞，截图如下所示。</p>
<p>SELECT * FROM TEST WITH(NOLOCK)</p>
<p><a href="http://images.cnitblog.com/blog/73542/201408/301158081574024.png" target="_blank" rel="noopener"><img src="http://images.cnitblog.com/blog/73542/201408/301158085323209.png" alt="image" title="image"></a></p>
<p>作者：<a href="http://www.cnblogs.com/kerrycode/" target="_blank" rel="noopener">潇湘隐者</a></p>
<p>出处：<a href="http://www.cnblogs.com/kerrycode/" target="_blank" rel="noopener">http://www.cnblogs.com/kerrycode/</a></p>
<p>本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.daahe.com/2015/10/14/sql-server-e4-b8-adwith-nolock-e6-b5-85-e6-9e-90/" data-id="cjo7e3rs6009obh0f8qljb5q9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-sys-sysprocesses-transact-sql" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/10/14/sys-sysprocesses-transact-sql/" class="article-date">
  <time datetime="2015-10-13T21:45:12.000Z" itemprop="datePublished">2015-10-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/数据库/">数据库</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/14/sys-sysprocesses-transact-sql/">sys.sysprocesses (Transact-SQL)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>含正在 SQL Server 实例上运行的进程的相关信息。这些进程可以是客户端进程或系统进程。若要访问 sysprocesses，您必须位于 master 数据库上下文中，或者必须使用由三部分构成的名称 master.dbo.sysprocesses。</p>
<p>列名</p>
<p>数据类型</p>
<p>说明</p>
<p>spid</p>
<p><strong>smallint</strong></p>
<p>SQL Server 会话 ID。</p>
<p>kpid</p>
<p><strong>smallint</strong></p>
<p>Windows 线程 ID。</p>
<p>blocked</p>
<p><strong>smallint</strong></p>
<p>正在阻塞请求的会话的 ID。如果此列为 NULL，则表示请求未被阻塞，或锁定会话的会话信息不可用（或无法进行标识）。 -2 = 阻塞资源由孤立的分布式事务拥有。 -3 = 阻塞资源由延迟的恢复事务拥有。 -4 = 由于内部闩锁状态转换而无法确定阻塞闩锁所有者的会话 ID。</p>
<p>waittype</p>
<p><strong>binary(2)</strong></p>
<p>保留。</p>
<p>waittime</p>
<p><strong>bigint</strong></p>
<p>当前等待时间（毫秒）。 0 = 进程不等待。</p>
<p>lastwaittype</p>
<p><strong>nchar(32)</strong></p>
<p>指示上次或当前等待类型名称的字符串。</p>
<p>waitresource</p>
<p><strong>nchar(256)</strong></p>
<p>锁资源的文本化表示法。</p>
<p>dbid</p>
<p><strong>smallint</strong></p>
<p>当前正由进程使用的数据库 ID。</p>
<p>uid</p>
<p><strong>smallint</strong></p>
<p>执行命令的用户 ID。如果用户数和角色数超过 32,767，则发生溢出或返回 NULL。有关详细信息，请参阅查询 SQL Server 系统目录。</p>
<p>cpu</p>
<p><strong>int</strong></p>
<p>进程的累计 CPU 时间。无论 SET STATISTICS TIME 选项是 ON 还是 OFF，都为所有进程更新该项。</p>
<p>physical_io</p>
<p><strong>int</strong></p>
<p>进程的累计磁盘读取和写入。</p>
<p>memusage</p>
<p><strong>int</strong></p>
<p>当前为此进程分配的过程缓存中的页数。一个负数，表示进程正在释放由另一个进程分配的内存。</p>
<p>login_time</p>
<p><strong>datetime</strong></p>
<p>客户端进程登录到服务器的时间。对于系统进程，将存储 SQL Server 的启动时间。</p>
<p>last_batch</p>
<p><strong>datetime</strong></p>
<p>客户端进程上次执行远程存储过程调用或 EXECUTE 语句的时间。对于系统进程，将存储 SQL Server 的启动时间。</p>
<p>ecid</p>
<p><strong>smallint</strong></p>
<p>用于唯一标识代表单个进程进行操作的子线程的执行上下文 ID。</p>
<p>open_tran</p>
<p><strong>smallint</strong></p>
<p>进程的打开事务数。</p>
<p>status</p>
<p><strong>nchar(30)</strong></p>
<p>进程 ID 状态。可能的值有： <strong>dormant</strong> = SQL Server 正在重置会话。 <strong>running</strong> = 会话正在运行一个或多个批。多个活动的结果集 (MARS) 启用后，会话可以运行多个批。有关详细信息，请参阅使用多个活动的结果集 (MARS)。 <strong>background</strong> = 会话正在运行一个后台任务，例如死锁检测。 <strong>rollback</strong> = 会话具有正在处理的事务回滚。 <strong>pending</strong> = 会话正在等待工作线程变为可用。 <strong>runnable</strong> = 会话中的任务在等待获取时间量程时位于计划程序的可执行队列中。 <strong>spinloop</strong> = 会话中的任务正在等待调节锁变为可用。 <strong>suspended</strong> = 会话正在等待事件（如 I/O）完成。</p>
<p>sid</p>
<p><strong>binary(86)</strong></p>
<p>用户的全局唯一标识符 (GUID)。</p>
<p>hostname</p>
<p><strong>nchar(128)</strong></p>
<p>工作站的名称。</p>
<p>program_name</p>
<p><strong>nchar(128)</strong></p>
<p>应用程序的名称。</p>
<p>hostprocess</p>
<p><strong>nchar(10)</strong></p>
<p>工作站进程 ID 号。</p>
<p>cmd</p>
<p><strong>nchar(16)</strong></p>
<p>当前正在执行的命令。</p>
<p>nt_domain</p>
<p><strong>nchar(128)</strong></p>
<p>客户端的 Windows 域（如果使用 Windows 身份验证）或可信连接的 Windows 域。</p>
<p>nt_username</p>
<p><strong>nchar(128)</strong></p>
<p>进程的 Windows 用户名（如果使用 Windows 身份验证）或可信连接的 Windows 用户名。</p>
<p>net_address</p>
<p><strong>nchar(12)</strong></p>
<p>为每个用户工作站上的网络适配器分配的唯一标识符。当用户登录时，该标识符插入 net_address 列。</p>
<p>net_library</p>
<p><strong>nchar(12)</strong></p>
<p>用于存储客户端网络库的列。每个客户端进程都在网络连接上进入。网络连接有一个与这些进程关联的网络库，该网络库使得这些进程可以建立连接。有关详细信息，请参阅网络协议和 TDS 端点。</p>
<p>loginame</p>
<p><strong>nchar(128)</strong></p>
<p>登录名。</p>
<p>context_info</p>
<p><strong>binary(128)</strong></p>
<p>使用 SET CONTEXT_INFO 语句存储在批中的数据。</p>
<p>sql_handle</p>
<p><strong>binary(20)</strong></p>
<p>表示当前正在执行的批或对象。 <strong>注意</strong>   此值是从对象的批或内存地址派生的。通过使用基于 SQL Server 哈希的算法无法计算此值。</p>
<p>stmt_start</p>
<p><strong>int</strong></p>
<p>为指定 sql_handle 运行当前 SQL 语句的起始偏移量。</p>
<p>stmt_end</p>
<p><strong>int</strong></p>
<p>所指定 sql_handle 的当前 SQL 语句的结束偏移量。 -1 指出当前语句为指定的 sql_handle 运行到 fn_get_sql 函数返回结果的结尾。</p>
<p>request_id</p>
<p><strong>int</strong></p>
<p>请求 ID。用于标识在特定会话中运行的请求。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.daahe.com/2015/10/14/sys-sysprocesses-transact-sql/" data-id="cjo7e3rsa009ubh0fgjqbf349" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-sql-server-e5-bf-ab-e7-85-a7-e4-ba-8b-e5-8a-a1-e9-9a-94-e7-a6-bb-e6-ad-bb-e9-94-81-e9-81-bf-e5-85-8d" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/10/14/sql-server-e5-bf-ab-e7-85-a7-e4-ba-8b-e5-8a-a1-e9-9a-94-e7-a6-bb-e6-ad-bb-e9-94-81-e9-81-bf-e5-85-8d/" class="article-date">
  <time datetime="2015-10-13T18:14:36.000Z" itemprop="datePublished">2015-10-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/数据库/">数据库</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/14/sql-server-e5-bf-ab-e7-85-a7-e4-ba-8b-e5-8a-a1-e9-9a-94-e7-a6-bb-e6-ad-bb-e9-94-81-e9-81-bf-e5-85-8d/">SQL Server 使用快照事务隔离避免死锁</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>使用基于行版本控制的隔离级别：2005中支持快照事务隔离和指定READ_COMMITTED隔离级别的事务使用行版本控制，可以将读与写操作之间发生的死锁几率降至最低： SET ALLOW_SNAPSHOT_ISOLATION ON –事务可以指定 SNAPSHOT 事务隔离级别; SET READ_COMMITTED_SNAPSHOT ON –指定 READ_COMMITTED 隔离级别的事务将使用行版本控制而不是锁定。默认情况下(没有开启此选项，没有加with nolock提示)，SELECT语句会对请求的资源加S锁(共享锁)；而开启了此选项后，SELECT不会对请求的资源加S锁。 在数据库中设置READ COMMITTED SNAPSHOT 或 ALLOW SNAPSHOT ISOLATIONON ON时，查询数据时不再使用请求共享锁，如果请求的行正被锁定(例如正在被更新)，SQL_Server会从行版本存储区返回最早的关于该行的记录(SQL_server会在更新时将之前的行数据在tempdb库中形成一个链接列表。</p>
<p>select name,user_access,user_access_desc,<br> snapshot_isolation_state,snapshot_isolation_state_desc,<br> is_read_committed_snapshot_on<br>from sys.databases;</p>
<p>ALTER DATABASE DBName SET SINGLE_USER WITH ROLLBACK IMMEDIATE<br>ALTER DATABASE DBName SET ALLOW_SNAPSHOT_ISOLATION ON<br>ALTER DATABASE DBName SET READ_COMMITTED_SNAPSHOT ON<br>ALTER DATABASE DBName SET MULTI_USER</p>
<p>注意：设置 READ_COMMITTED_SNAPSHOT选项时，数据库中只允许存在执行 ALTER DATABASE命令的连接。在 ALTER DATABASE完成之前，数据库中决不能有其他打开的连接。数据库不必一定要处于单用户模式中。 参考：<a href="https://msdn.microsoft.com/zh-cn/library/tcbchxcb(v=vs.80" target="_blank" rel="noopener">使用快照隔离 https://msdn.microsoft.com/zh-cn/library/tcbchxcb(v=vs.80).aspx</a>.aspx)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.daahe.com/2015/10/14/sql-server-e5-bf-ab-e7-85-a7-e4-ba-8b-e5-8a-a1-e9-9a-94-e7-a6-bb-e6-ad-bb-e9-94-81-e9-81-bf-e5-85-8d/" data-id="cjo7e3rs5009mbh0fiesdhkn8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-e9-9c-80-e8-a6-81-e6-88-91-e4-bb-ac-e4-ba-86-e8-a7-a3-e7-9a-84sql-server-e9-98-bb-e5-a1-9e-e5-8e-9f-e5-9b-a0-e4-b8-8e-e8-a7-a3-e5-86-b3-e6-96-b9-e6-b3-95" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/10/13/e9-9c-80-e8-a6-81-e6-88-91-e4-bb-ac-e4-ba-86-e8-a7-a3-e7-9a-84sql-server-e9-98-bb-e5-a1-9e-e5-8e-9f-e5-9b-a0-e4-b8-8e-e8-a7-a3-e5-86-b3-e6-96-b9-e6-b3-95/" class="article-date">
  <time datetime="2015-10-12T21:43:37.000Z" itemprop="datePublished">2015-10-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/数据库/">数据库</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/13/e9-9c-80-e8-a6-81-e6-88-91-e4-bb-ac-e4-ba-86-e8-a7-a3-e7-9a-84sql-server-e9-98-bb-e5-a1-9e-e5-8e-9f-e5-9b-a0-e4-b8-8e-e8-a7-a3-e5-86-b3-e6-96-b9-e6-b3-95/">需要我们了解的SQL Server阻塞原因与解决方法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>上篇说<a href="http://www.cnblogs.com/cnsym/p/3227766.html" target="_blank" rel="noopener">SQL Server应用模式之OLTP系统性能分析</a>。五种角度分析sql性能问题。本章依然是SQL性能 五种角度其一“阻塞与死锁”</p>
<p>这里通过连接在sysprocesses里字段值的组合来分析阻塞源头，可以把阻塞分为以下5种常见的类型（见表）。waittype,open_tran,status,都是sysprocesses里的值，“自我修复？”列的意思,就是指阻塞能不能自动消失。 <strong> 5种常见的阻塞类型</strong></p>
<p>类型</p>
<p>waittype</p>
<p>open_tran</p>
<p>status</p>
<p>自我修复</p>
<p>原因/其他特征</p>
<p>1</p>
<p>不为0</p>
<blockquote>
<p>=0</p>
</blockquote>
<p>runnable</p>
<p>是的，当语句运行结束后</p>
<p>语句运行的时间比较长，运行时需等待某些系统资源（如硬盘读写、CPU或内存等）。</p>
<p>2</p>
<p>0x0000</p>
<blockquote>
<p>0</p>
</blockquote>
<p>sleeping</p>
<p>不能，但是如果运行 KILL语句，这个链接能够很容易被终止</p>
<p>可能客户端遇到了一个语句执行超时，或者主动取消了上一语句的执行，但是没有回滚开启的事务，在SQL Trace里能够看到一个Attention事件</p>
<p>3</p>
<p>0x0000 0x0800 0x0063</p>
<blockquote>
<p>=0</p>
</blockquote>
<p>runnable</p>
<p>不能。知道客户端吧所有结果都主动取走，或者主动断开连接，可以运行KILL语句去终止它，但是可能要花长达30秒</p>
<p>客户端没有及时把所有结果都取走，这时可能open_tran=0，事务隔离级别也为默认（READ COMMITTED），但这个连接还会持有锁资源</p>
<p>4</p>
<p>0x0000</p>
<blockquote>
<p>0</p>
</blockquote>
<p>rollback</p>
<p>是的</p>
<p>在SQL Trace里能够看到这个SPID已经发来了一个Attention事件，说明客户端已经遇到了超时，或者主动要求回滚事务</p>
<p>5</p>
<p>各种值都有可能</p>
<blockquote>
<p>=0</p>
</blockquote>
<p>runnable</p>
<p>不能，直到客户端取消语句运行或者主动断开连接。可以运行KILL语句终止它，但是可能要花长达30秒</p>
<p>应用程序运行中产生死锁，在SQL Server中以阻塞形式体现。Sysprocesses里阻塞和被阻塞的连接hostname值是一样的</p>
<p>  下面详细介绍这些类型产生的原因，以及解决方法</p>
<p>类型1：由于语句运行时间太长而导致的阻塞，语句本身在正常运行中，只须等待某些系统资源。</p>
<p>解决方法： 要解决这一类阻塞，数据库管理员需要和数据库应用设计人员合作，共同解决以下问题。</p>
<ol>
<li>语句本身有没有可优化的空间？ 这里包括修改语句本身降低复杂度、修改表格设计、调整索引等。</li>
<li>SQL Server整体性能如何？是不是有资源瓶颈影响了语句执行速度？ 当SQL Server 遇到诸如内存、硬盘读写、CPU等资源瓶颈是，原来能很快完成的语句有可能会花很长时间。</li>
<li>如果语句天生就很复杂，无法调优（很多处理报表的语句就是这样），就须考虑怎样把这一类应用（一般就是数据仓库应用）从OLTP系统中隔离出来。</li>
</ol>
<p>类型2：由于一个未按预期提交的事务导致的阻塞</p>
<p>这一类阻塞的特征，就是问题连接早就进入了空闲状态（sysprocesses.status=’sleeping’和sysprocesses.cmd=’AWAITING COMMAND’），但是，如果检查sysprocesses.open_tran，就会发现它不为0，以及事务没有提交。这类问题很多都是因为应用端遇到一个执行超时，或者其他原因，当时执行的语句被提前终止了，但是连接还保留着。应用没有跟随发来的事务提交或回滚指令，导致一个事务被遗留在SQL Server里。 遇到这类问题，许多使用者会误以为是SQL Server端什么地方没有处理好。其实，执行超时（command timeout）完全是一个客户端的行为。当客户端应用向SQL Server发来语句执行请求时，自己会有一个执行超时设置。一般ADO或ADO.NET的连接超时时限是30秒。如果30秒以内SQL Server没有完成语句返回任何结果，客户端就会发送一个Attention的消息给SQL Server，告诉SQL Server它不想继续等下去了。SQL Server收到这个消息后，会终止当前正在运行的语句（或批处理）。但是，为了维护客户端的逻辑，SQL Server默认不会自动回滚或提交这个连接已经打开的事务，而是等待客户端的后续决定。如果客户端不发来回滚或提交指令，SQL Server会永远的把这个事务保持下去，直到客户端断开连接为止。 这里可以用下面这个实验来模拟这个问题。在Management Studio里创建一个连接到SQL Server，运行下面的批处理语句：</p>
<p><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<p>use sqlnexus<br>        go<br>BEGIN TRAN<br>SELECT <em><br>FROM ReadTrace.tblInterestingEvents<br>WITH(HOLDLOCK) SELECT<br>    \</em><br>FROM sysobjects s1,sysobjects<br>    s2 COMMIT TRAN</p>
<p><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<p>由于使用了HOLDLOCK参数，第一句SELECT会在运行结束后，在表格上维持一个TAB的S锁。如果批处理全部完成，这个锁会在提交事务的时候释放。但是第二句的SELECT会执行很久。请在等待3～4秒钟以后取消执行。然后运行下面的语句，检查open_tran和锁的情况。</p>
<p>SELECT @@TRANCOUNT<br>GO sp_lock GO</p>
<p>通过结果（见图）可以得知： <img src="http://images.cnitblog.com/blog/326630/201308/01171538-1bb326e52b414e1ca6988331067ee7f0.jpg" alt=""> (1)     批处理被取消的时候，“COMMIT TRAN”这条语句没有被执行到。SQL Server没有对“BEGIN TRAN”开启的那个事务做任何处理，只保持其活动的状态。 (2)     第一句SELECT带来的锁由于事务没有结束，所以锁还保持着（objID=85575343, Type=TAB, Mode=IS）。 现在，如果有其他连接要修改ReadTrace.tblInterestingEvents这张表，就会被阻塞住。 解决办法： 1. 应用程序本身必须意识到审核语句都有可能遇到意外终止情况，做好错误处理工作。这些工作包括 a)   在做SQL Server调用的时候，必须加上错误捕捉和处理语句 SQL Server客户端驱动程序（包括ODBC和OLE DB）当语句执行遇到意外终止（包括超时）的时候，都会向应用返回错误信息。客户端在捕捉到错误信息时。除了做记录以外（这对问题定位非常有帮助），还要运行下面这句话，把没有提交的事务回滚掉。</p>
<p>IF @@TRANCOUNT&gt;0 ROLLBACK TRAN</p>
<p>  有些程序员会问，我在T-SQL批处理里已经写了T-SQL层面的错误捕捉和处理语句（IF @@ERROR&lt;&gt;0 ROLLBACK TRAN）,还有必要让应用程序再做一遍么？需要意识到的是，有些异常（比如超时）终止的是整个T-SQL批处理的执行，而不仅仅是当前语句。所以当这些异常发生的时候，T-SQL层面错误捕捉和处理语句很可能也一起被取消了。它们不能发挥想象中的作用。在应用程序里的错误捕捉和处理语句是必不可少的。 b)   设置连接属性“SET SACT_ABORT ON” 当SET SACT_ABORT为ON时，如果执行T-SQL语句产生运行错误，整个事务将会终止并回滚 当SET SACT_ABORT为OFF时，处理方法不是唯一的。有时只回滚产生错误的T-SQL语句，而事务将继续进行处理。如果错误很严重，及时SET SACT_ABORT 为OFF，也可能回滚整个事务。OFF是默认设置。 如果没有办法很快规范应用程序的错误捕捉和处理语句，一个最快的方法就是在每个连接建立以后，或者是容易出问题的存储过程的开头，运行“SET XACT_ABORT ON”，让SQL Server帮助应用程序回滚事务。 c)   考虑是否要关闭连接池 一般的SQL Server应用都会使用连接池来得到良好的性能。如果有一个连接忘记把事务关闭就推出连接，那么这个连接会被交还给连接池，但是这个时候事务不会被清理。客户端驱动程序会在这个连接下一次被重用的时候（又有新的用户要建立连接），发一句sp_reset_connection命令清理当前连接上次遗留下来的所有对象，包括回滚未提交的事务。如果连接交还给连接池以后很久都没有被重用，那它的事务就会持续长时间，引起阻塞。有些Java程序使用的驱动程序，提供连接池功能，但是不提供连接重用时的事务清理功能。这样的连接池对应用开发质量要求很高，比较容易发生阻塞。 如果不能很快的实施建议a)和b)，把连接池关闭能缩短食事务持续时间，也能从一定程度上缓解阻塞问题。 2. 分析为什么连接会遇到异常终止 这里又得谈到错误信息记录了。有了错误信息，就可以判定是超时问题，还是其他SQL Server错误。如果是超时问题，可按照第一种阻塞进行处理。 还有一种孤儿事务的来源，是连接开启了隐式事务（implicit transaction）而没有加入及时提交事务的机制。如果连接处于隐式事务模式（SET IMPLICIT_TRANSACTIONS ON），并且连接当前不再事务中，则执行下列任何一条语句都会开启一个新的事务。</p>
<p>ALTER TABLE</p>
<p>FETCH</p>
<p>REVOKE</p>
<p>CREATE</p>
<p>GRANT</p>
<p>SELECT</p>
<p>DELETE</p>
<p>INSERT</p>
<p>TRUNCATE_TABLE</p>
<p>DROP</p>
<p>OPEN</p>
<p>UPDATE</p>
<p>对于因为此设置为ON而自动打开的事务，SQL Server会自动帮你打开事务，但是不会自动帮你提交。用户必须在该事务结束后将其显式提交或回滚。否则，当用户断开连接时，事务及其包含的所有数据更改将被回滚。事务提交后，执行上述任意一条语句又会启动一个新事务。隐式事务模式将始终生效，知道连接执行SET IMPLICIT_TRANSACTIONS OFF语句使连接恢复为自动提交模式。在自动提交模式下，所有单个语句在成功完成时将被提交，不会有事务遗留。 为什么会有连接要开启隐式事务呢？除了程序员有意为之以外，很多是客户端数据库连接驱动，或者空间为了实现它的事务功能（注意不是SQL Server通过T-SQL语句直接提供的）而选用这个机制。如果应用程序出现意外，或者脚本没有处理好，会有应用层事务未提交的现象。在SQL Server里也体现为一个孤儿事务。严格约束应用层对事务的使用，直接使用SQL Server里面的事务，是避免这种问题出现的好方法。  </p>
<p>类型3：由于客户端没有及时把结果集取出而导致的语句长时间运行。</p>
<p> 语句在SQL Server内执行总时间不仅包含SQL Server的执行时间，还包含把结果集发给客户端的时间。如果结果集比较大，SQL Server会分几次打包发出，每发一次，都要等待客户端的确认。只有确认以后，SQL Server才会发送下一个结果集包。所有结果都发完以后，SQL Server才认为语句执行完毕，释放执行申请的资源（包括锁资源）。 如果处于某种原因，客户端应用处理结果非常缓慢甚至没有相应，或者干脆不理睬SQL Server发送结果集的请求，则SQL Server会耐心的等待，因此会导致语句长时间执行而发生阻塞。 解决方法：</p>
<ol>
<li>在设计程序时，一定要慎重返回大结果集。这种行为不仅会对SQL Server和网络带来很大负担，对应用程序本身来讲，也要花很多资源去处理结果集。如果最终用户只需要部分结果集就可以，则在发送SQL Server指令的时候就要指定好。要避免居于不管三七二十一所有数据都要，而结果集只取走开头一部分去展示这样的行为发生。</li>
<li>如果应用程序的确须返回大结果集，例如一些报表系统，则要考虑报表数据库和生产数据库分开。</li>
<li>如果1和2在短期内不能实现，可以和最终用户协商，返回大结果集的连接使用READ UNCOMMITTED事务隔离级别。这样查询语句就不会申请S锁了。</li>
</ol>
<p>类型4：阻塞的源头连接一直处于rollback状态。</p>
<p>这种情况常是由第一类情况衍生来的。有时候数据库管理员发现一个连接阻塞住了别人，为了解决问题，会让连接主动退出或强制退出（轻质退出应用，或者直接在SQL Server端KILL连接）。对于大部分情况，这些措施会消除阻塞。但是要记住的是，不管是在客户端退出，还是要服务器端KILL，为了维护数据库事务的一致性，SQL Server都会对连接还没有来得及完成提交的事务做回滚动作。SQL Server要找到所有当前事务修改过的记录，把它们改回原来的状态。所以，如果一个DELETE、INSERT或UPDATE已经运行了一个小时，可能回滚也需要一个小时，在这个过程中，阻塞还会延续，我们只能等待。 有些用户可能等不及，直接重启SQL Server。当SQL Server关闭的时候，回滚动作会被中断，SQL Server会被很快关掉，但是这个回滚动作在下次SQL Server重启的时候会重新开始（数据库做恢复的时候）。重启的时候如果回滚不能很快结束，整个数据库都不可用，可能会带来更严重的后果。 解决方法： 最好的方法是在工作时间尽量不要做这种大的修改操作。这些操作尽量安排在半夜或者周末的时间完成。如果操作已经做了很久，最好耐心等它做完。如果一定要在有工作负荷的时候做，最好把一个大操作分成若干小操作分步完成。  </p>
<p>类型5：应用程序运行中产生死锁，在SQL Server中以阻塞形式体现。</p>
<p>一个客户端的应用在运行过程中会使用到许多资源，包括线程资源，信号量资源，内存资源，IO资源等，SQL Server也是资源之一。如果发生死锁的两端不全是SQL Server，SQL Server的死锁判断机制可能不起作用。这时如果应用端没有处理好，可能会永远等下去。而SQL Server内部的表现可能仅仅是一个阻塞。但是这个阻塞不会自动消除。这样的阻塞对SQL Server的性能会产生很大影响。 下面我们举两个这种应用端死锁的例子。 1)  在应用的一个线程中开启不止一个数据库连接而产生的死锁（见图）。 假设应用有一个线程有这样的逻辑： ●  开始运行 ●  建立数据库连接A，调用存储过程ProcA。打开结果集A。 ●  建立数据库连接B，调用存储过程ProcB。打开结果集B。 ●  轮流读取结果集A、B，整合输出最终结果。 ●  关闭结果集A、B，关机连接A、B。 ●  结束运行 <img src="http://images.cnitblog.com/blog/326630/201308/01171636-34c58042436e47bab5a3904bd711d864.jpg" alt=""> 在正常情况下这样的设计看上去没有问题，但是实际上很脆弱。因为在线程内部，这个逻辑是线程执行的。假设存储过程ProcA是一个事务，在返回结果集之前因为一些操作申请了一些排他锁，而ProcB为了返回结果又要用到这些锁，那会发生什么情况呢？ 发生的情况会是连接A在等线程把连接B上的结果读出来，再来处理结果集A，而连接B等待连接A完成事务后再释放锁。双方相互等待，产生思索。 1)  两个线程间的死锁（见图）。 如果应用有两个线程，每个线程各开一个数据库连接，那上面的逻辑不会出问题。因为运行ProcA的那个线程会先做完，释放阻塞住连接B的锁，让B也能够接着跑完。但是假设有下列逻辑： 线程A：建立数据库连接A，不断读取表格A，按条取出记录，做一定处理后发给线程B的输入缓存。 线程B：建立数据库连接B，从输入缓存读取数据，依据收到的记录对表格A进行修改。 这个逻辑会产生什么问题呢？我们知道表格修改会在表上申请一些排他锁。如果线程A正在读取这条记录，修改动作会被阻塞住。这个时候线程B就会进入等待状态。但是线程A需要线程B输入缓存清空后才能写入。如果线程B还没来得及清空，它也不得不等待，这时候也会产生死锁（在SQL Server里是一个阻塞）。 <img src="http://images.cnitblog.com/blog/326630/201308/01171710-13a4bcd66ec14b6fa57fb59baebc8190.jpg" alt=""> 解决方法: 复杂的程序还可能会出现其他的死锁形式。为了避免这种死锁，要在应用调用SQL Server的时候设置执行超时，并写好错误处理机制（参见阻塞原因2）。一旦死锁发生，SQL Server的操作在等待一段时间后会因为超时而放弃，并释放出SQL Server内部的资源，解决死锁。 <strong>小结：应更多从程序设计着手解决阻塞问题</strong> 很多用户有一种误解，认为阻塞是一个数据库问题。当阻塞问题发生的时候，都希望从数据库层面找到方法，一劳永逸地解决问题。可是，阻塞本身是为了完成事务的隔离，是应用程序向SQL Server提出的要求。所以很多时候，光从数据库端努力是不能解决阻塞问题的。在应用程序层面也要做很多工作。例如应用在做连接的时候选择什么样的隔离级别，事务开始和结束的时间点选择，连接的建立和回收机制，指令复杂度的控制等。应用程序还应该考虑到控制结果集大小，并及时从SQL Server端取走数据。还要考虑SQL Server指令执行时间长短控制，以及发生超时或其他意外后的错误处理机制等。尤其是对高并发量、高响应要求的关键业务系统，在设计应用时必须要考虑好上面这些关键因素。对于关键的业务逻辑，必须逐个审查，保证应用选择的是能够满足业务需求的最低隔离级别，事务的大小已经控制到了最小的粒度。而运行的语句，也要有良好的数据库设计，保证它不会随着数据库的增大和用户量的增多，占用更多的资源和运行时间。如果做不到这几点，就会容易发生应用在用户量比较少，或者数据库比较小的初始阶段性能不错，但是当用户量增长或数据量增大以后性能越来越慢的问题。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.daahe.com/2015/10/13/e9-9c-80-e8-a6-81-e6-88-91-e4-bb-ac-e4-ba-86-e8-a7-a3-e7-9a-84sql-server-e9-98-bb-e5-a1-9e-e5-8e-9f-e5-9b-a0-e4-b8-8e-e8-a7-a3-e5-86-b3-e6-96-b9-e6-b3-95/" data-id="cjo7e3rqt006fbh0fwj3fn92m" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-e5-90-af-e5-8a-a8sql-server-profiler-ef-bc-8c-e5-88-9b-e5-bb-batrace-e8-b7-9f-e8-b8-aa" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/10/09/e5-90-af-e5-8a-a8sql-server-profiler-ef-bc-8c-e5-88-9b-e5-bb-batrace-e8-b7-9f-e8-b8-aa/" class="article-date">
  <time datetime="2015-10-08T22:43:04.000Z" itemprop="datePublished">2015-10-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/数据库/">数据库</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/09/e5-90-af-e5-8a-a8sql-server-profiler-ef-bc-8c-e5-88-9b-e5-bb-batrace-e8-b7-9f-e8-b8-aa/">启动SQL Server Profiler，创建Trace(跟踪)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>启动SQL Server Profiler，创建Trace(跟踪).</strong> 启动SQL Server Profiler工具(在Microsoft SQL Server Management Studio的工具菜单上就发现它)，创建一个Trace,Trace属性选择主要是包含: Deadlock graph Lock: Deadlock Lock: Deadlock Chain RPC:Completed SP:StmtCompleted SQL:BatchCompleted SQL:BatchStarting <strong>分析死锁</strong> 如下图，我们可以看到第一个会话在SPID 54,第二个会话在SPID 55,一旦SQL Server发现死锁，它就会确定一个优胜者，可成功执行，和另一个作为牺牲品，要回滚。 可以到看到EventClass列中，两条SQL:BatchCompleted事件紧跟在Lock:DealLock后面，其中一条，它就是作为牺牲品，它会被回滚.而另一条SQL:BatchCompleted将会是优胜者，成功执行。 那么，谁是优胜者，谁是牺牲品呢? 不用着急，通过DealLock graph事件，所返回来的信息，我们可以知道结果。 <img src="http://image20.it168.com/201111_500x375/867/cdf5ced3ff071285.png" alt=""> <img src="http://image20.it168.com/201111_500x375/867/629364eed3b930f6.png" alt=""> 我们虽然不能明白DealLock graph图示的含义，但通过图中描述的关系，我们知道一些有用的信息。图中左右两旁椭圆形相当一个处理节点(Process Node),当鼠标移动到上面的时候，可以看到内部执行的代码，如Insert,UPdate,Delete.有打叉的左边椭圆形就是牺牲者，没有打叉的右边椭圆形是优胜者。中间两个长方形就是一个资源节点(Resource Node)，描述数据库中的对象,如一个表、一行或一个索引。在我们当前的实例中，资源节点描述的是，在聚集索引请求获得排它锁(X)。椭圆形与长方形之间，带箭头的连线表示，处理节点与资源节点的关系，包含描述锁的模式. 接下来我们更详细的看图里面的数据说明。 先看右边作为优胜者的这椭圆形，我们可以看到内容包含有： <strong>服务器进程 ID</strong>： 服务器进程标识符 (SPID)，即服务器给拥有锁的进程分配的标识符。 <strong>服务器批 ID</strong>： 服务器批标识符 (SBID)。 <strong>执行上下文 ID</strong>： 执行上下文标识符 (ECID)。与指定 SPID 相关联的给定线程的执行上下文 ID。ECID = {0,1,2,3, …n}，其中 0 始终表示主线程或父线程，并且 {1,2,3, …n} 表示子线程。 <strong>死锁优先级</strong>： 进程的死锁优先级有关可能值的详细信息，请参阅 SET DEADLOCK_PRIORITY (Transact-SQL)。 <strong>已用日志</strong>： 进程所使用的日志空间量。 <strong>所有者 ID</strong>： 正在使用事务并且当前正在等待锁的进程的事务 ID。 <strong>事务描述符</strong>： 指向描述事务状态的事务描述符的指针。 这些数据描述，对于我们理解死锁，只需要知道其中的一些就够，除非我们在专门SQL Server机构工作，才可能要深入理解它们。 <img src="http://image20.it168.com/201111_500x375/867/915884fb2522edca.png" alt=""> 下面我们来看左边作为牺牲品的这椭圆形处理节点，它告诉我们以下信息： 它是一个失败的事务。(蓝色的交叉表示) 它是作为牺牲品的T-SQL代码。 它对右下方的资源节点有一个排它锁(X). 它对右上方的资源节点请求 一个排它锁(X). <img src="http://image20.it168.com/201111_500x375/867/d9515ef0e0bbbe90.png" alt=""> 我们再来看中间两个长方形的资源节点,两个处理节点对它们各自都使用权，来执行它们各自的代码，同时又有对对方使用资源请求的动作，从而发生了资源的竞争。 这也就让我们明白死锁发生的原因。 这里说明下资源节点的一些信息： HoBT：　　堆或 B 树。 用于保护没有聚集索引的表中的 B 树(索引)或堆数据页的锁 associated objid: 关联的对象ID,这里只是索引关联的对象ID. Index name:索引名 <img src="http://image20.it168.com/201111_500x375/867/1868d081f509c9dd.png" alt=""> 让我们再对SQL Server Profiler监视到的数据，作一次整理： 回顾图： <img src="http://image20.it168.com/201111_500x375/867/e0041122b9ebfafa.png" alt=""> 在第3行SQL:BatchStarting, SPID 54 (第一个会话启动),在索引PK__DealLock__3214EC274222D4EF获得一个排它锁，再处理等待状态，(因为在这个实例中我设置了Waitfor Delay ‘00:00:05’) 在第6行SQL:BatchStarting, SPID 55 (第二个会话启动),在索引PK__DealLock__3214EC2745F365D3获得一个排它锁，再处理等待状态，(因为在这个实例中我设置了Waitfor Delay ‘00:00:05’) 两个进程都各自获得一个排它锁(X),几秒过去，它们就开始请求排它锁。 SPID 54 (第一个会话),先对PK__DealLock__3214EC2745F365D3请求一个排它锁(X),但PK__DealLock__3214EC2745F365D3当前已经给SPID 55 (第二个会话)获得。SPID 54要于等待。 同时， SPID 55 (第二个会话),开始对PK__DealLock__3214EC274222D4EF请求一个排它锁(X),但PK__DealLock__3214EC274222D4EF当前已经给SPID 54 (第一个会话)获得。SPID 55要等待。 这里就出现了进程阻塞，从而发生死锁。 SQL Server 检查到这两个进程(第一个&amp;第二个会话)发生死锁，并对占用资源比较少的进程，列入牺牲品名单，将它终止(Kill)。通过左右椭圆形进程节点显示，可以发现已用日志最少的是左边的进程节点。 SPID 54 (第一个会话)被回滚(Rollback)，SPID 55 (第二个会话)执行成功。 到这里我们已算完成了，对死锁的监视和分析。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.daahe.com/2015/10/09/e5-90-af-e5-8a-a8sql-server-profiler-ef-bc-8c-e5-88-9b-e5-bb-batrace-e8-b7-9f-e8-b8-aa/" data-id="cjo7e3rpt0040bh0f9unh6ye0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/j2ee/">j2ee</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/j2ee/Linux/">Linux</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android/道听途说/">道听途说</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/DataCross/">DataCross</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flex/">Flex</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hibernate/">Hibernate</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/j2ee/">j2ee</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/jvm/">jvm</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/redis/">redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/未分类/">未分类</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/生活/">生活</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/生活/道听途说/">道听途说</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/私人日志/">私人日志</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/道听途说/">道听途说</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Google-Map/">Google Map</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MapView/">MapView</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/UI设计/">UI设计</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/datacross/">datacross</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ui/">ui</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/xp-启动不输入密码/">xp 启动不输入密码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/切换/">切换</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/原则/">原则</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/开发/">开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据转换/">数据转换</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/格式转换/">格式转换</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/横屏/">横屏</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/注销/">注销</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/监听/">监听</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/竖屏/">竖屏</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/返回/">返回</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android/" style="font-size: 20px;">Android</a> <a href="/tags/Google-Map/" style="font-size: 10px;">Google Map</a> <a href="/tags/MapView/" style="font-size: 10px;">MapView</a> <a href="/tags/UI设计/" style="font-size: 10px;">UI设计</a> <a href="/tags/datacross/" style="font-size: 10px;">datacross</a> <a href="/tags/ui/" style="font-size: 10px;">ui</a> <a href="/tags/xp-启动不输入密码/" style="font-size: 10px;">xp 启动不输入密码</a> <a href="/tags/切换/" style="font-size: 10px;">切换</a> <a href="/tags/原则/" style="font-size: 10px;">原则</a> <a href="/tags/开发/" style="font-size: 15px;">开发</a> <a href="/tags/数据转换/" style="font-size: 10px;">数据转换</a> <a href="/tags/格式转换/" style="font-size: 10px;">格式转换</a> <a href="/tags/横屏/" style="font-size: 10px;">横屏</a> <a href="/tags/注销/" style="font-size: 10px;">注销</a> <a href="/tags/监听/" style="font-size: 10px;">监听</a> <a href="/tags/竖屏/" style="font-size: 10px;">竖屏</a> <a href="/tags/返回/" style="font-size: 10px;">返回</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">October 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">August 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/07/">July 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/">May 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04/">April 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/03/">March 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/05/">May 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/02/">February 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/12/">December 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/11/">November 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/10/">October 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/05/">May 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/04/">April 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/03/">March 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/01/">January 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/12/">December 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/11/">November 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/09/">September 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/02/">February 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/01/">January 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/12/">December 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/11/">November 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/10/">October 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/09/">September 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/08/">August 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/07/">July 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/06/">June 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/05/">May 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/04/">April 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/03/">March 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/02/">February 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/01/">January 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2010/12/">December 2010</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2010/11/">November 2010</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2010/09/">September 2010</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2010/08/">August 2010</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2007/12/">December 2007</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2007/10/">October 2007</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2007/09/">September 2007</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/11/07/java-JNDI/">JNDI -- java名与目录接口</a>
          </li>
        
          <li>
            <a href="/2018/11/07/java-multi-thread/">java-multi-thread</a>
          </li>
        
          <li>
            <a href="/2018/11/07/java-io/">java-io</a>
          </li>
        
          <li>
            <a href="/2018/11/07/message-queue2/">消息队列</a>
          </li>
        
          <li>
            <a href="/2018/11/07/cache/">缓存技术</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 daahe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    
<script src="https://code.jquery.com/jquery-3.3.1.min.js"></script>
<!-- script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script -->


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>